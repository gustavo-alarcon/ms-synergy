{"version":3,"sources":["../../../node_modules/rxjs/node_modules/tslib/tslib.es6.js","../../../node_modules/rxjs/src/internal/util/isObject.ts","../../../node_modules/rxjs/src/internal/util/tryCatch.ts","../../../node_modules/rxjs/src/internal/Subscription.ts","../../../node_modules/rxjs/src/internal/util/toSubscriber.ts","../../../node_modules/rxjs/src/internal/util/pipe.ts","../../../node_modules/rxjs/src/internal/Observable.ts","../../../node_modules/rxjs/src/internal/observable/empty.ts","../../../node_modules/rxjs/src/internal/util/isScheduler.ts","../../../node_modules/rxjs/src/internal/observable/fromArray.ts","../../../node_modules/rxjs/src/internal/operators/map.ts","../../../node_modules/rxjs/src/internal/util/isPromise.ts","../../../node_modules/rxjs/src/internal/util/subscribeToResult.ts","../../../node_modules/rxjs/src/internal/util/isObservable.ts","../../../node_modules/rxjs/src/internal/util/isIterable.ts","../../../node_modules/rxjs/src/internal/observable/fromPromise.ts","../../../node_modules/rxjs/src/internal/observable/fromIterable.ts","../../../node_modules/rxjs/src/internal/observable/fromObservable.ts","../../../node_modules/rxjs/src/internal/observable/from.ts","../../../node_modules/rxjs/src/internal/operators/mergeMap.ts","../../../node_modules/rxjs/src/internal/operators/mergeAll.ts","../../../node_modules/rxjs/src/internal/observable/merge.ts","../../../src/lib/popover/popover.errors.ts","../../../node_modules/rxjs/src/internal/operators/take.ts","../../../src/lib/popover/popover-anchoring.service.ts","../../../node_modules/src/cdk/bidi/dir-document-token.ts","../../../node_modules/src/cdk/bidi/directionality.ts","../../../node_modules/src/cdk/bidi/dir.ts","../../../node_modules/src/cdk/bidi/bidi-module.ts","../../../src/lib/popover/popover.animations.ts","../../../node_modules/rxjs/src/internal/config.ts","../../../node_modules/rxjs/src/internal/Observer.ts","../../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../../../node_modules/rxjs/src/internal/Subscriber.ts","../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../../../node_modules/rxjs/src/internal/SubjectSubscription.ts","../../../node_modules/rxjs/src/internal/Subject.ts","../../../node_modules/rxjs/src/internal/util/subscribeToArray.ts","../../../node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts","../../../node_modules/rxjs/src/internal/OuterSubscriber.ts","../../../node_modules/rxjs/src/internal/InnerSubscriber.ts","../../../node_modules/rxjs/src/internal/util/subscribeToPromise.ts","../../../node_modules/rxjs/src/internal/symbol/iterator.ts","../../../node_modules/rxjs/src/internal/util/subscribeToIterable.ts","../../../node_modules/rxjs/src/internal/util/subscribeToObservable.ts","../../../node_modules/rxjs/src/internal/util/subscribeTo.ts","../../../src/lib/popover/notification.service.ts","../../../src/lib/popover/popover.component.ts","../../../node_modules/rxjs/src/internal/operators/filter.ts","../../../node_modules/rxjs/src/internal/operators/tap.ts","../../../node_modules/rxjs/src/internal/operators/takeUntil.ts","../../../src/lib/popover/popover-anchor.directive.ts","../../../src/lib/popover/popover.module.ts"],"names":["__extends","d","b","__","this","constructor","extendStatics","prototype","Object","create","isObject","x","errorObject","e","fn","tryCatchTarget","flattenUnsubscriptionErrors","errors","toSubscriber","nextOrObserver","error","complete","Subscriber","rxSubscriber","fns","length","input","getPromiseCtor","promiseCtor","scheduler","isScheduler","value","fromArray","Observable","subscriber","sub","Subscription","i","add","schedule","next","closed","project","isPromise","subscribeToResult","outerSubscriber","result","outerValue","outerIndex","destination","InnerSubscriber","isObservable","isIterable","fromPromise","err","fromIterable","iterator","iterator$$1","return","Symbol_iterator","done","fromObservable","observable","from","concurrent","Number","POSITIVE_INFINITY","source","pipe","mergeMap","a","map","ii","resultSelector","lift","MergeMapOperator","last","observables","pop","getInvalidPopoverError","Error","getUnanchoredPopoverError","getInvalidHorizontalAlignError","alignment","generateGenericError","VALID_HORIZ_ALIGN","getInvalidVerticalAlignError","VALID_VERT_ALIGN","getInvalidScrollStrategyError","strategy","VALID_SCROLL","apiName","invalid","valid","v","join","count","getHorizontalPopoverAlignment","h","getVerticalPopoverAlignment","getHorizontalConnectionPosPair","originX","overlayX","getVerticalConnectionPosPair","originY","overlayY","prioritizeAroundTarget","target","options","targetIndex","indexOf","reordered","left","slice","right","reverse","push","DIR_DOCUMENT","InjectionToken","providedIn","factory","inject","DOCUMENT","Directionality","_document","change","EventEmitter","bodyDir","body","dir","htmlDir","documentElement","type","Injectable","args","undefined","decorators","Optional","Inject","_dir","_isInitialized","defineProperty","Dir","old","emit","ngAfterContentInit","ngOnDestroy","Directive","selector","providers","provide","useExisting","host","[dir]","exportAs","Output","Input","NgModule","exports","declarations","BidiModule","transformPopover","trigger","transition","style","opacity","transform","animate","setPrototypeOf","__proto__","Array","p","hasOwnProperty","_enable_super_gross_mode_that_will_cause_bad_things","Promise","empty","config","useDeprecatedSynchronousErrorHandling","UnsubscriptionError","_super","_this","call","name","tslib_1.__extends","_parent","_parents","_subscriptions","unsubscribe","hasErrors","_a","_unsubscribe","index","len","remove","isFunction","trial","tryCatch","isArray","teardown","EMPTY","subscription","tmp","_addParent","subscriptions","subscriptionIndex","parent","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destinationOrNext","isTrustedSubscriber","trustedSubscriber","SafeSubscriber","_next","_error","_complete","_parentSubscriber","context","observerOrNext","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","hostReportError","_isScalar","subscribe","operator","observable$$1","sink","forEach","reject","operations","toPromise","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","AnonymousSubject","copy","thrownError","_trySubscribe","_subscribe","asObservable","array","ArgumentOutOfRangeError","MapOperator","MapSubscriber","thisArg","OuterSubscriber","notifyNext","innerValue","innerIndex","innerSub","notifyError","notifyComplete","subscribeToPromise","promise","Symbol","getSymbolIterator","subscribeToIterable","iterable","item","subscribeToObservable","obj","obs","subscribeTo","Symbol_observable","hasCompleted","MergeMapSubscriber","_tryNext","buffer","active","_innerSub","shift","PopoverNotification","action","PopoverNotificationService","dispatch","notification","store","events","dispose","DEFAULT_TRANSITION","SatPopover","_focusTrapFactory","_horizontalAlign","val","_validateHorizontalAlign","_dispatchConfigNotification","NotificationAction","REPOSITION","horizontalAlign","_verticalAlign","_validateVerticalAlign","verticalAlign","_forceAlignment","coercedVal","coerceBooleanProperty","_lockAlignment","_autoFocus","_scrollStrategy","_validateScrollStrategy","UPDATE_CONFIG","_hasBackdrop","_interactiveClose","_openTransition","_closeTransition","ngOnInit","_setAlignmentClasses","_notifications","open","OPEN","_dispatchActionNotification","close","CLOSE","toggle","TOGGLE","isOpen","_open","_getAnimation","params","openTransition","closeTransition","_onAnimationDone","event","toState","_trapFocus","afterOpen","_restoreFocus","afterClose","horizAlign","vertAlign","_classList","_savePreviouslyFocusedElement","_focusTrapElement","_focusTrap","nativeElement","autoFocus","focusInitialElementWhenReady","toFocus","_previouslyFocusedElement","focus","destroy","pos","Component","encapsulation","ViewEncapsulation","None","animations","styles","template","FocusTrapFactory","ViewChild","TemplateRef","FilterOperator","predicate","FilterSubscriber","DoOperator","TapSubscriber","_tapNext","noop","_tapError","_tapComplete","TakeOperator","total","TakeSubscriber","TakeUntilOperator","takeUntilSubscriber","TakeUntilSubscriber","notifierSubscription","notifier","PopoverAnchoringService","_overlay","_ngZone","_destroyPopover","_notificationsSubscription","_positionChangeSubscription","_onDestroy","popoverOpened","popoverClosed","anchor","popover","viewContainerRef","_popover","_viewContainerRef","_anchor","_subscribeToNotifications","isPopoverOpen","_popoverOpen","togglePopover","closePopover","openPopover","createOverlay","_subscribeToBackdrop","_subscribeToEscape","_subscribeToDetachments","_saveOpenedState","_overlayRef","_saveClosedState","detach","_portal","TemplatePortal","_templateRef","popoverConfig","hasBackdrop","backdropClass","scrollStrategy","forceAlignment","lockAlignment","overlayConfig","_getOverlayConfig","_subscribeToPositionChanges","attach","_destroyPopoverOnceClosed","detachments","take","takeUntil","backdropClick","tap","backdropClicked","filter","interactiveClose","keydownEvents","overlayKeydown","keyCode","ESCAPE","opened","_getDirection","OverlayConfig","positionStrategy","_getPositionStrategy","_getScrollStrategyInstance","direction","position","onPositionChange","run","connectionPair","scrollStrategies","block","reposition","horizontalTarget","verticalTarget","_b","connectedTo","withDirection","withLockedPosition","_addFallbacks","hTarget","vTarget","horizontalOverlapAllowed","verticalOverlapAllowed","possibleHorizontalAlignments","possibleVerticalAlignments","fallbacks","_applyFallback","withFallbackPosition","Overlay","NgZone","SatPopoverAnchor","_elementRef","_anchoring","_attachedPopover","_validateAttachedPopover","attachedPopover","merge","ElementRef","ViewContainerRef","SatPopoverModule","imports","CommonModule","OverlayModule","A11yModule"],"mappings":"6tBAoBA,SAAgBA,EAAUC,EAAGC,GAEzB,SAASC,IAAOC,KAAKC,YAAcJ,EADnCK,GAAcL,EAAGC,GAEjBD,EAAEM,UAAkB,OAANL,EAAaM,OAAOC,OAAOP,IAAMC,EAAGI,UAAYL,EAAEK,UAAW,IAAIJ,mGCtBrEO,EAAQC,sGCQlBC,GAAAC,EAAAA,iBAKkBC,UACpBC,EAAsBD,ICwMxB,SAAAE,EAAAC,wJCtNA,SAAAC,EAAAC,EAAAC,EAAAC,MAUIF,EAAA,IACEA,aAAAG,eAIAH,EAAAI,0BAKFJ,GAAAC,GAAAC,8DCEAG,EAIU,IAAVA,EAAAC,qBAIkBC,6DCyTfC,EAAAC,MACHA,4BAIAA,+DCvSgBC,0HCnDNC,EAAiBC,2CCD/B,SAAAC,EAAAN,EAAAG,cAQeI,GAHXJ,EAGW,SAAqBK,GAC9B,IAAIC,EAAM,IAAAC,GACNC,EAAI,WACNC,IAAIT,EAAAU,SAAkB,WACpBF,IAAAX,EAAWD,QAIbS,EAAAM,KAAgBd,EAAMW,MACpBH,EAAYO,gCAJZP,EAAAb,qFC0Be,mBAAnBqB,yHCxCQC,EAAAZ,uECId,SAAAa,EAAAC,EAAAC,EAU2DC,EAAYC,GAErE,IAAAC,EAAkB,IAAAC,GAAoBL,EAAAE,EAAAC,4BCZ1BG,EAAAzB,+CCDA0B,EAAW1B,sCCFzB,SAAA2B,EAAA3B,EAAAG,cAQeI,GAHXJ,EAGW,SAAqBK,GAC9B,IAAIC,EAAG,IAAAC,YAEHE,IAAIT,EAAAU,SAAA,qCAEFJ,EAAIG,IAAIT,EAAUU,SAAS,uBAG5BD,IAAAT,EAAAU,SAAA,WAAA,OAAAL,EAAAb,kBAGF,SAAAiC,KACQhB,IAAAT,EAAAU,SAAA,WAAA,OAAAL,EAAAd,MAAAkC,qBCpBjB,SAKcC,EAAA7B,EAAAG,OACVH,wDAMWO,GAHXJ,EAGW,SAAqBK,GAC9B,IACIsB,EADArB,EAAA,IAAAC,YAEFE,IAAA,WAEEkB,GAAQ,mBAAAC,EAAAC,uBAIVpB,IAAAT,EAAAU,SAAA,WACAiB,EAAQ9B,EAASiC,QACfrB,IAAIT,EAAUU,SAAS,eACrBL,EAAAO,QAGF,IAAIV,EACA6B,MAEF,IAAAd,EAAAW,EAAqBjB,OACrBT,EAAAe,EAAcf,oCAGdG,EAAAd,MAAAkC,GAGAM,gBAGA1B,EAAAM,KAAgBT,qCCzC5B,SAAA8B,EAAAnC,EAAAG,cAUeI,GAHXJ,EAGW,SAAqBK,GAC9B,IAAIC,EAAG,IAAAC,YACLE,IAAMT,EAAUU,SAA0B,WAC1C,IAAIuB,EAAAA,EAAAA,QACFxB,IAAIwB,EAAAA,WACJtB,KAAA,SAAAT,GAAAI,EAAiBG,IAAIT,EAAUU,SAAS,WAAA,OAAAL,EAAiBM,KAAMT,OAC/DX,MAAA,SAAAkC,GAAanB,EAAIG,IAAIT,EAAUU,SAAS,WAAM,OAAAL,EAAWd,MAAAkC,OACvDjC,SAAA,WAAAc,EAAAG,IAAAT,EAAAU,SAAA,WAAA,OAAAL,EAAAb,+BCjBZ,SAAA0C,EAckBrC,EAAAG,OACdA,SACEH,aAAAO,sBAMF,MAAAP,EAAA,IACEyB,EAAAzB,6CAIiBA,0BAEqB,iIC4CtC,IAAAsC,IACFA,EAAAC,OAAAC,wCAOA,SAAAC,GAA2B,OAAAA,EAAAC,KAAAC,EAAA,SAAAC,EAAAjC,GAAA,OAAA0B,EAAArB,EAAA4B,EAAAjC,IAAA+B,KAAAG,EAAA,SAAArE,EAAAsE,GAAA,OAAAC,EAAAH,EAAApE,EAAAmC,EAAAmC,OAAAR,gCAM7B,SAAAG,GAAA,OAAAA,EAAAO,KACiE,IAAAC,GAAAjC,EAAAsB,gCCrCjE,IAAAA,8GCgCD,IAAIA,EAAAC,OAAAC,kBACCrC,EAAA,KACA+C,EAAAC,EAAmBA,EAAApD,OAAA,UACrBK,EAA2B8C,IAC3B/C,EAAAgD,EAAAC,MACED,EAAApD,OAAA,GAAA,iBAAAoD,EAAAA,EAAApD,OAAA,iDAOF,OAAAI,GAAqC,IAAAgD,EAAApD,QAAAoD,EAAA,aAAA5C,qBC9FzC,SAAA8C,IACE,OAAOC,MAAM,uEAGf,SAAAC,IACE,OAAOD,MAAM,uDAGf,SAAAE,EAA+CC,GAC7C,OAAOH,MAAMI,EAAqB,yBAA0BD,EAAWE,KAGzE,SAAAC,EAA6CH,GAC3C,OAAOH,MAAMI,EAAqB,uBAAwBD,EAAWI,KAGvE,SAAAC,EAA8CC,GAC5C,OAAOT,MAAMI,EAAqB,iBAAkBK,EAAUC,KAGhE,SAAAN,EAA8BO,EAAiBC,EAAcC,GAC3D,MAAO,WAAWF,EAAO,MAAMC,EAAO,wBACjCC,EAAMtB,IAAI,SAAAuB,GAAK,MAAA,IAAIA,EAAC,MAAKC,KAAK,MAAK,iJCiBhCC,6BAEJ,IAAAA,oFCyXN,SAAAC,EAAuCC,GACrC,MAAU,UAANA,EACK,QAGC,QAANA,EACK,SAGF,SAIT,SAAAC,EAAqCL,GACnC,MAAU,QAANA,EACK,QAGC,WAANA,EACK,QAGF,SAIT,SAAAM,EAAwCF,GAEtC,OAAQA,GACN,IAAK,SACH,OAAQG,QAAS,QAASC,SAAU,OACtC,IAAK,QACH,OAAQD,QAAS,QAASC,SAAU,SACtC,IAAK,MACH,OAAQD,QAAS,MAAOC,SAAU,OACpC,IAAK,QACH,OAAQD,QAAS,MAAOC,SAAU,SACpC,QACE,OAAQD,QAAS,SAAUC,SAAU,WAK3C,SAAAC,EAAsCT,GAEpC,OAAQA,GACN,IAAK,QACH,OAAQU,QAAS,MAAOC,SAAU,UACpC,IAAK,QACH,OAAQD,QAAS,MAAOC,SAAU,OACpC,IAAK,MACH,OAAQD,QAAS,SAAUC,SAAU,UACvC,IAAK,QACH,OAAQD,QAAS,SAAUC,SAAU,OACvC,QACE,OAAQD,QAAS,SAAUC,SAAU,WAa3C,SAAAC,EAAmCC,EAAWC,GAW5C,IAVA,IAAMC,EAAcD,EAAQE,QAAQH,GAG9BI,GAAaJ,GAGbK,EAAOJ,EAAQK,MAAM,EAAGJ,GACxBK,EAAQN,EAAQK,MAAMJ,EAAc,EAAGD,EAAQnF,QAAQ0F,UAGtDH,EAAKvF,QAAUyF,EAAMzF,QAC1BsF,EAAUK,KAAKF,EAAMpC,OACrBiC,EAAUK,KAAKJ,EAAKlC,OAItB,KAAOoC,EAAMzF,QACXsF,EAAUK,KAAKF,EAAMpC,OAIvB,KAAOkC,EAAKvF,QACVsF,EAAUK,KAAKJ,EAAKlC,OAGtB,OAAOiC,ECveT,IvBzBAhG,EuByBasG,GAAe,IAAIC,EAAAA,eAAyB,eACvDC,WAAY,OACZC,QAAS,WAAM,OAAAC,EAAAA,OAAOC,EAAAA,2BCFtB,SAAFC,EAAgDC,GAC5C,GANJxH,KAAA2B,MAA8B,MAG9B3B,KAAAyH,OAAoB,IAAIC,EAAAA,aAGhBF,EAAW,CAKb,IAAMG,EAAUH,EAAUI,KAAOJ,EAAUI,KAAKC,IAAM,KAChDC,EAAUN,EAAUO,gBAAkBP,EAAUO,gBAAgBF,IAAM,KAC5E7H,KAAK2B,MAASgG,GAAWG,GAAW,OAnC1C,sBAmBAE,KAACC,EAAAA,WAADC,OAAaf,WAAY,+CAQzBa,UAAAG,EAAAC,aAAAJ,KAAeK,EAAAA,WAAfL,KAA2BM,EAAAA,OAA3BJ,MAAkCjB,iIA3BlCM,gCCgCAvH,KAAAuI,KAAoB,MAGpBvI,KAAAwI,gBAAoC,EAGpCxI,KAAAyH,OAAgC,IAAIC,EAAAA,aAtCpC,OA0CAtH,OAAAqI,eAAMC,EAANvI,UAAA,WAAA,WAAyB,OAAOH,KAAKuI,UACnC,SAAQ7C,GACN,IAAMiD,EAAM3I,KAAKuI,KACjBvI,KAAKuI,KAAO7C,EACRiD,IAAQ3I,KAAKuI,MAAQvI,KAAKwI,gBAC5BxI,KAAKyH,OAAOmB,KAAK5I,KAAKuI,uCAK1BnI,OAAFqI,eAAMC,EAANvI,UAAA,aAAE,WAAyB,OAAOH,KAAK6H,qCAGrCa,EAAFvI,UAAA0I,mBAAE,WACE7I,KAAKwI,gBAAiB,GAGxBE,EAAFvI,UAAA2I,YAAE,WACE9I,KAAKyH,OAAOxG,2BAnChB+G,KAACe,EAAAA,UAADb,OACEc,SAAU,QACVC,YAAaC,QAAS3B,GAAgB4B,YAAaT,IACnDU,MAAOC,QAAS,OAChBC,SAAU,4BASZ7B,SAAAO,KAAGuB,EAAAA,OAAHrB,MAAU,eAGVL,MAAAG,KAAGwB,EAAAA,SAzCHd,iCCAA,sBAYAV,KAACyB,EAAAA,SAADvB,OACEwB,SAAUhB,IACViB,cAAejB,QAdjBkB,KCSaC,GAA6CC,EAAAA,QAAQ,oBAChEC,EAAAA,WAAW,UACTC,EAAAA,OAAOC,QAAS,EAAGC,UAAW,eAC9BC,EAAAA,QAAQ,qBACNH,EAAAA,OAAOC,QAAS,EAAGC,UAAW,gBAElCH,EAAAA,WAAW,UACTI,EAAAA,QAAQ,sBACNH,EAAAA,OAAOC,QAAS,EAAGC,UAAW,oB7BDhChK,GAAgBE,OAAOgK,iBACpBC,wBAA2BC,OAAS,SAAUzK,EAAGC,GAAKD,EAAEwK,UAAYvK,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIyK,KAAKzK,EAAOA,EAAE0K,eAAeD,KAAI1K,EAAE0K,GAAKzK,EAAEyK,K8BhBzEE,IAAA,MAWEC,aAAAvC,4CASExG,GACEA,IACA,IAAAiD,2ECtBN+F,IAIEtI,QAAA,EACAD,KAAA,SAAAT,0BAEIiJ,GAAMC,wJCL6BC,GAAA,SAAKC,qBAGrCC,EAAAD,EAAAE,KAAAjL,KAAAa,0IAELmK,EAAKnK,OAAAA,EACJmK,EAAcE,KAAA,oEALjBC,EAAAA,EAAAA,KADuC,Q7BoCvCnJ,GAAA,yBAPAhC,KAAAqC,QAAA,EAEArC,KAAAoL,QAAA,KAEApL,KAAAqL,SAAgB,KAQdrL,KAAIsL,eAAA,KACKC,mEAaT,IAEI1K,EAFA2K,GAAA,MAGFxL,KAAAqC,QAKF,IAAIoJ,EAAAzL,KAAAoL,EAAAK,EAAAL,QAAAC,EAAAI,EAAAJ,SAAAK,EAAAD,EAAAC,aAAAJ,EAAAG,EAAAH,eACJtL,KAAKqC,QAAA,EACLrC,KAAKoL,QAAA,KACLpL,KAAAqL,SAAA,KAIArL,KAAIsL,eAAA,SACJ,IAAIK,GAAA,EAEJC,EAAAP,EAAAA,EAAAhK,OAAA,KAIE+J,EAAAS,OAAA7L,6BAMA8L,EAAAJ,KACIK,EAAKC,EAAAN,GAAAT,KAAAjL,SACPQ,KACAgL,GAAS,WAEuB/K,aAAaqK,2BAO/CmB,GAAQX,OACRK,GAAA,EAEAC,EAAAN,EAAoBjK,WACNuK,GAAA,CACZ,IAAI7J,EAAAuJ,EAAAK,MACFrL,EAASyB,GAAG,CACZ,IAAIgK,EAAKC,EAAAjK,EAAgBwJ,aAAAN,KAAAlJ,MACvBgK,IAAAvL,GAAA,CACAgL,GAAS,EACT3K,EAAAA,MACA,IAAIqC,EAAG1C,GAAAC,EACLyC,aAAe4H,0CAUvBU,gCAuBgBtJ,IAAA,SAAAgK,OAChBA,GAAAA,IAAAlK,EAAAmK,wBAIAD,IAAAlM,iBAKF,IAAAoM,EAAAF,6DAKME,EAAA/J,QAAmB,mBAAA+J,EAAAb,2CAGnBa,EAAAb,oDAGA,IAAAc,EAAAD,GACAA,EAAY,IAAApK,iHASlBhC,KAAAsL,iBAAAtL,KAAAsL,oBACatE,KAAAoF,GAEbA,EAAAE,WAAAtM,4BAU2B,SAAAoM,GAC3B,IAAIG,EAAavM,KAAAsL,kBACfiB,EAAA,CACA,IAAIC,EAAiBD,EAAA7F,QAAA0F,IACnB,IAAAI,sDAQJ,IAAIf,EAAAzL,KAAAoL,EAAAK,EAAwBL,QAAAC,EAAAI,EAAAJ,SAC1BD,GAAAA,IAAAqB,8FAjLF9B,EAAAtI,QAAY,cAgBd,2G8BtBiCnB,GAAA,SAAY6J,qBAwB7C,IAAAC,EAAAD,EAAAE,KAAAjL,OAAAA,YACiBgL,EAAA0B,eAAA,KACA1B,EAAA2B,iBAAkB,IAECC,oBAAA,EAgBlC5B,EAAA6B,WAAkB,2BAGd7B,EAAMnI,YAAA8H,oBAGJmC,EAAmB,CACnB9B,EAAMnI,YAAA8H,YAGN,iBAAAmC,EAAA,IAGEC,EAAAD,GAAA,CACA,IAAAE,EAAuBF,EAAA3L,MACvB6J,EAAK4B,mBAAAI,EAAAJ,mBACL5B,EAAAnI,YAAiBmK,gBAGjBhC,EAAK4B,oBAAkB,0CAM3B5B,EAAK4B,oBAAkB,EACvB5B,EAAMnI,YAAA,IAAAoK,GAAAjC,EAAA8B,EAAA9L,EAAAC,mBAvCZkK,EAAAA,EAAAA,GA3BAjK,EAAAf,UAAAgB,IAAA,WAAA,OAAAnB,0BAeoCgB,EAAAC,GAClC,IAAAa,EAAA,IAAAZ,EAAgCkB,EAAMpB,EAAAC,UACtCa,EAAA8K,oBAAA,sBA6DqB,SAAAjL,GACnB3B,KAAK6M,wDAaL7M,KAAK6M,YACL7M,KAAK6M,WAAY,mDAYjB7M,KAAK6M,YACL7M,KAAK6M,WAAY,iCAKFtB,YAAA,WACfvL,KAAAqC,SAGFrC,KAAA6M,WAAM,mDAIWK,MAAK,SAAAvL,yCAILwL,OAAS,SAAAjK,GAC1BlD,KAAK6C,YAAW7B,MAAAkC,mCAICkK,UAAA,WACjBpN,KAAK6C,YAAW5B,6EAMhB,IAAIwK,EAAAzL,KAAWoL,EAAAK,EAAAL,QAAAC,EAAAI,EAAAJ,gBACfrL,KAAKoL,QAAA,KACLpL,KAAKqL,SAAW,KAChBrL,KAAKuL,cACLvL,KAAKqC,QAAS,EACdrC,KAAK6M,WAAA,EACL7M,KAAKoL,QAAAA,EACLpL,KAAAqL,SAAAA,UAlJ+B,KA2JH4B,GAAA,SAAalC,uBAIvB,IAAAC,EAAAD,EAAAE,KAAiBjL,OAAAA,KAMnCgL,EAAAqC,kBAAAA,EACA,IAAIjL,EAEAkL,EAAUtC,SACZc,EAAAyB,WAGAnL,EAAAmL,EAA6CnL,KAC7CpB,EAAQuM,EAAAvM,MACRC,EAAAsM,EAAAtM,SACEsM,IAAA5C,KAEEmB,GADFwB,EAAAlN,OAAAC,OAAuBkN,IACShC,iFAOpCP,EAAKwC,SAAQF,EACbtC,EAAKkC,MAAA9K,EACL4I,EAAKmC,OAASnM,yBA3BhBmK,EAAAA,EAAAA,KA+BYhL,UAAAiC,KAAkB,SAAAT,OAClB3B,KAAA6M,WAAA7M,KAAAkN,MAAA,CACR,IAAIG,EAAArN,KAAAqN,kBACFzC,GAAAC,uCAAAwC,EAAAT,mBAEK5M,KAAAyN,gBAAAJ,EAAArN,KAAAkN,MAAAvL,2DAMCxB,UAAWa,MAAA,SAAAkC,OACXlD,KAAA6M,UAAA,CACA,IAAAQ,EAAArN,KAAAqN,kBACJxC,EAAAD,GAAAC,yCACF7K,KAAKmN,OACHtC,GAAAwC,EAAAT,oBAIA5M,KAAKyN,gBAAAJ,EAAArN,KAAAmN,OAAAjK,wBAHLlD,KAAK0N,aAAa1N,KAAAmN,OAAAjK,+BAMfmK,EAAAT,mBAOH/B,GACAwC,EAAkBX,eAAAxJ,oDARf,IACLlD,KAAIuL,cACFV,kDAgBN,IAAIG,EAAKhL,SACCA,KAAA6M,UAAA,CACR,IAAIQ,EAAArN,KAAAqN,qBACFrN,KAAMoN,UAAA,CAEN,IAAIO,EAAA,WAAA,OAAA3C,EAA6CoC,UAAAnC,KAAAD,EAAAwC,WAC/C5C,GAAAC,uCAAAwC,EAAAT,oBAIA5M,KAAKyN,gBAAAJ,EAAAM,wBAHL3N,KAAK0N,aAAaC,gIAgBtB3N,KAAIuL,cACFX,GAAMC,uDAQC1K,UAAAsN,gBAAA,SAAsChB,EAAA/L,EAAAiB,OAC/CiJ,GAAAC,8GAMED,GAAOC,uCACP4B,EAAOC,eAAAxJ,EACPuJ,EAAOE,iBAAA,OAGPiB,EAAA1K,qDASJ,IAAImK,EAAiBrN,KAAAqN,kBACrBrN,KAAKwN,SAAA,KACLxN,KAAAqN,kBAAA,wBAnI4B,qE3BhJ9BxL,GAAA,yBAQE7B,KAAI6N,WAAA,EACFC,0CA2BiBxJ,KAAI,SAAgByJ,GACvC,IAAAC,EAAiB,IAAAnM,SACjB6B,EAAWK,OAAA/D,KACX0D,EAAAA,SAAAA,2BA2H0B,SAAA6J,EAAAvM,EAAAC,GAC1B,IAAM8M,EAAA/N,KAAA+N,SAEFE,EAAAnN,EAAAyM,EAAAvM,EAAAC,MACF8M,2GAMAnD,GAAAC,uCACEoD,EAAKrB,qBACLqB,EAAIrB,oBAAsB,EACxBqB,EAAAtB,+HAcF/B,GAAAC,wCACAoD,EAAKtB,iBAAA,+CA+BVuB,QAAA,SAAA9L,EAAAZ,GAjBC,IAAAwJ,EAAAhL,gBAEAwB,EAAWD,EAAAC,kBAIT,IAAA4K,8CAKI+B,EAAAjL,GACEkJ,gEAUR,IAAArI,EAAa/D,KAAI+D,mCAsBV5D,UAAAuD,IAAA,qHAqCa,IAAlB0K,EAAkB/M,oCAmBrBgN,UAAA,SAAA7M,GANC,IAAAwJ,EAAAhL,gBAEAwB,EAAWD,EAAAC,kBAET,IAAAG,6FArRKtB,OAAA,SAAAyN,sBAzBT,G4BpB2CQ,GAAA,SAAKvD,gBAG9C,IAAAC,EAAAD,EAAAE,KAAAjL,KAAA,wBAAAA,YACCgL,EAAcE,KAAA,wEAHjBC,EAAAA,EAAAA,KAD2C,QCADoD,GAAA,SAAYxD,mBAGnC,IAAAC,EAAAD,EAAAE,KAAmBjL,OAAAA,YAASgL,EAAAwD,QAAUA,EAFzDxD,EAAAlJ,WAAAA,uBAEAqJ,EAAAA,EAAAA,KAKiBhL,UAAAoL,YAAA,eACbvL,KAAAqC,QAKFrC,KAAMqC,QAAU,EAChB,IAAMmM,EAAAxO,KAAAwO,QAEFC,EAAAD,EAAAC,aAEJzO,KAAKwO,QAAA,KACHC,GAAA,IAAAA,EAAApN,SAAAmN,EAAA3B,YAAA2B,EAAAnM,QAKF,IAAIqM,EAAeD,EAAA/H,QAAA1G,KAAA8B,aACjB,IAAA4M,sBA1BsC,KCGFC,GAAA,SAAa5D,iBAC/B,IAAAC,EAAAD,EAAAE,KAAAjL,KAAA6C,IAAA7C,qCAAtBmL,EAAAA,EAAAA,KADwC,KASVyD,GAAA,SAAa7D,gBAM3C,IAAAC,EAAAD,EAA2BE,KAAAjL,OAAAA,YAE3BgL,EAAAyD,aAEAzD,EAAA3I,QAAS,EAET2I,EAAA6B,WAAA,EAEA7B,EAAA6D,UAAW,8BAEX1D,EAAAA,EAAAA,mBAbmC,kCAuB3BhL,UAAUmE,KAAI,SAAAyJ,GACpB,IAAAS,EAAA,IAAAM,GAAA9O,KAAAA,aACAwO,EAAYT,SAAAA,OAIR5N,UAAAiC,KAAA,SAAAT,MACF3B,KAAAqC,wBAGQrC,KAAA6M,kBACF4B,EAAAzO,KAAgByO,UAChB7C,EAAA6C,EAAgBpN,OACtB0N,EAAAN,EAAoB5H,QACb5E,EAAC,EAAMA,EAAC2J,EAAM3J,oBAMnB9B,UAAAa,MAAA,SAAAkC,MACFlD,KAAAqC,oBAGFrC,KAAK6O,UAAW,EAChB7O,KAAKgP,YAAA9L,EACGlD,KAAA6M,WAAA,UACF4B,EAAAzO,KAAgByO,UAChB7C,EAAA6C,EAAgBpN,OACtB0N,EAAAN,EAAoB5H,QACb5E,EAAC,EAAAA,EAAO2J,EAAM3J,6CAMjB9B,UAAAc,SAAA,cACFjB,KAAAqC,oBAGMrC,KAAA6M,WAAA,UACF4B,EAAAzO,KAAgByO,UAChB7C,EAAA6C,EAAgBpN,OACtB0N,EAAAN,EAAoB5H,QACb5E,EAAC,EAAAA,EAAU2J,EAAG3J,+CAMjB9B,UAAUoL,YAAA,WACdvL,KAAK6M,WAAS,EACd7M,KAAKqC,QAAS,yBAKVlC,UAAA8O,cAAA,SAAAnN,MACF9B,KAAAqC,qEAQElC,UAAA+O,WAAA,SAAApN,MACF9B,KAAAqC,gCAEUwM,UACV/M,EAAAd,MAAAhB,KAAAgP,4BAEUnC,WACV/K,EAAAb,sBAGAjB,KAAAyO,UAAAzH,KAAAlF,sBAKI3B,UAAUgP,aAAA,WACV,IAAAzL,EAAkB,IAAA7B,UACxB6B,EAAAK,OAAiB/D,qDA7GW,KAoHS8O,GAAA,SAAU/D,mBAC3B,IAAAC,EAAAD,EAAAE,KAAAjL,OAAAA,YAEpBgL,EAAKnI,YAAAA,sBAFPsI,EAAAA,EAAAA,gCAOE,IAAItI,EAAW7C,KAAA6C,YACbA,GAAWA,EAAAT,+CAMb,IAAIS,EAAW7C,KAAA6C,YACbA,GAAAA,EAA2B7B,uDAKV,WACnB,IAAI6B,EAAW7C,KAAA6C,YACbA,GAAAA,EAA2B5B,iFAOnBjB,KAAA+D,4CA9B2B,K7BhIzCoI,GAAA,IAAAtK,GAAA,SAAAC,GAAA,OAAAA,EAAAb,yB8BFsCmO,uEAGZA,EAAAnN,6BCAmBoN,GAAA,SAAKtE,gBAG9C,IAAAC,EAAAD,EAAAE,KAAAjL,KAAA,0BAAAA,YACCgL,EAAcE,KAAA,wEAHjBC,EAAAA,EAAAA,KAD2C,Q5BsC3CmE,gBAAA,2BAAqEtP,KAAAsC,QAAAA,0BAI5DnC,UAAA8K,KAAA,SAAAnJ,EAAAiC,8DAJT,IAagCwL,GAAA,SAAaxE,gBAOrCzI,EAAWkN,GAFC,IAAAxE,EAAAD,EAAAE,KAAuCjL,KAAA6C,IAAA7C,YAJ3DgL,EAAA1I,QAAkBA,EAOhB0I,EAAKpF,MAAA,0BAJPuF,EAAAA,EAAAA,KAUiBhL,UAAA+M,MAAA,SAAAvL,GACf,IAAIe,4EAIF1C,KAAA6C,YAAA7B,MAAAkC,+BAnB4B,K6BrDSuM,GAAA,SAAa1E,sEAAxDI,EAAAA,EAAAA,eAI0BuE,WAAU,SAAA/M,EAAAgN,EAAA/M,EAAAgN,EAAAC,yCAIVC,YAAA,SAAA9O,EAAA6O,oGARiB,KCAA/M,GAAA,SAAaiI,gBAI7CpI,EAAAC,GADW,IAAAoI,EAAMD,EAAAE,KAAAjL,OAAAA,YAAgCgL,EAAAyB,OAAAA,EAAsBzB,EAAArI,WAAAA,EAFxEqI,EAAApI,WAAUA,qBAElBuI,EAAAA,EAA0DJ,KAK5C5K,UAAU+M,MAAK,SAAavL,kFAI5BxB,UAAAgN,OAAmB,SAAAnM,GAC/BhB,KAAKyM,OAAAqD,YAAA9O,EAAAhB,4BAIOG,UAAAiN,UAAmB,WAC/BpN,KAAKyM,OAAAsD,eAAA/P,4BAlBkC,KCJlCgQ,GACC,SAAAC,gDAGFnO,EAAAO,kCAMC,SAAUa,GAAA,OAAApB,EAAAd,MAAAkC,sBCJnBE,oBARW,mBAAA8M,QAAAA,OAAA9M,sCAQX+M,GCPAC,GAAA,SAC2CC,GACzC,OAAA,SAAAvO,GAEE,IADA,IAAMsB,EAAAA,EAAoBG,QAC1B,CACE,IAAA+M,EAAWlN,EAAQhB,OACnB,GAAAkO,EAAA9M,KAAA,uBAIA1B,EAAAM,KAAAkO,EAAA3O,4BAOA,mBAAA0B,EAAAC,oDCXKiN,GAAwB,SAAAC,GACjC,OAAA,SAAA1O,GACE,IAAA2O,EAAAD,EAAA9M,MACA,GAAA,mBAAA+M,EAAA3C,4KCVJ4C,GAAA,SAAAhO,MAaIA,aAAAb,6BAEIa,EAAAmL,WACA/L,EAAWM,KAAAM,EAAWf,YACtBG,EAAAb,yHAYyB0P,qBAAAA,iBAG7B,uBAAMrQ,EAAAoC,GAAsB,oBAAA,IAAAA,EAAA,4H1BsDH,wBACsCkB,iLADtC,yCAkBnB,IAAAA,MACmBC,OAAAC,gFAUzBkH,EAAA4F,cAAkB,2BAEXjF,MAAA,kBAGTkF,EAAA1Q,UAAA+M,MAAA,SAAAvL,+BAGM3B,KAAA8Q,SAAAnP,GAGF3B,KAAA+Q,OAAA/J,KAAArF,yCAGAe,iBAEF,IACIA,EAAA1C,KAAAsC,QAAAX,EAAAgK,wBAIA3L,KAAK6C,YAAA7B,MAAwBkC,GAIjClD,KAAKgR,SACLhR,KAAIiR,UAAWvO,EAAMf,EAASgK,yFAQI,yEAI5B3L,KAAA6C,YAAA5B,4DAIJ4B,YAAAT,KAAkBuN,MACJxP,UAAW4P,eAAA,SAAAF,OACzBkB,EAAA/Q,KAAA+Q,oDAzDuD7D,MAAA6D,EAAAG,8Q2BtF7D,IAAAC,GAAA,kBACE,SAESC,EAEAzP,GAFA3B,KAAAoR,OAAAA,EAEApR,KAAA2B,MAAAA,GALX,yCAYkB,IAAIiN,UAGpByC,EAAAlR,UAAAmR,SAAA,SAASC,GACPvR,KAAKwR,MAAMpP,KAAKmP,IAIlBF,EAAAlR,UAAAsR,OAAA,WACE,OAAOzR,KAAKwR,MAAMrC,gBAIpBkC,EAAAlR,UAAAuR,QAAA,WACE1R,KAAKwR,MAAMvQ,gCAjBdgH,EAAAA,kBCUY3C,IAA4C,OAAQ,QAAS,aAAc,SAC3EL,IACR,SAAU,QAAS,SAAU,MAAO,SAC5BE,IACR,QAAS,QAAS,SAAU,MAAO,SAGlCwM,GAAsB,uDA2K1B,SAAAC,EACUC,EAC8BrK,GAD9BxH,KAAA6R,kBAAAA,EAC8B7R,KAAAwH,UAAAA,wBAxJc,6BAiBJ,+BAiBxB,uBAeD,mBAQJ,uBAY+B,gCAQ7B,0BAQK,uBAUFmK,yBAUCA,sBAGF,eAGN,IAAIjK,EAAAA,yBAGJ,IAAIA,EAAAA,4BAGD,IAAIA,EAAAA,6BAGH,IAAIA,EAAAA,kCAGC,IAAIA,EAAAA,iCAGL,IAAIA,EAAAA,4CASvB,+BA/IJkK,EAAAzR,UAAA,kCAAoB,OAAOH,KAAK8R,sBACpC,SAAoBC,GAClB/R,KAAKgS,yBAAyBD,GAC1B/R,KAAK8R,mBAAqBC,IAC5B/R,KAAK8R,iBAAmBC,EACxB/R,KAAKiS,4BAA4B,IAAId,GAAoBe,GAAmBC,qEAO5EP,EAAAzR,UAAA,yBAAW,OAAOH,KAAKoS,qBAC3B,SAAWL,GAAkC/R,KAAKoS,gBAAkBL,yDAIhEH,EAAAzR,UAAA,gCAAkB,OAAOH,KAAKqS,oBAClC,SAAkBN,GAChB/R,KAAKsS,uBAAuBP,GACxB/R,KAAKqS,iBAAmBN,IAC1B/R,KAAKqS,eAAiBN,EACtB/R,KAAKiS,4BAA4B,IAAId,GAAoBe,GAAmBC,qEAO5EP,EAAAzR,UAAA,yBAAW,OAAOH,KAAKuS,mBAC3B,SAAWR,GAAgC/R,KAAKuS,cAAgBR,yDAI5DH,EAAAzR,UAAA,iCAAmB,OAAOH,KAAKwS,qBACnC,SAAmBT,GACjB,IAAMU,EAAaC,EAAAA,sBAAsBX,GACrC/R,KAAKwS,kBAAoBC,IAC3BzS,KAAKwS,gBAAkBC,EACvBzS,KAAKiS,4BAA4B,IAAId,GAAoBe,GAAmBC,qEAU5EP,EAAAzR,UAAA,gCAAkB,OAAOH,KAAK2S,oBAClC,SAAkBZ,GAChB,IAAMU,EAAaC,EAAAA,sBAAsBX,GACrC/R,KAAK2S,iBAAmBF,IAC1BzS,KAAK2S,eAAiBD,EAAAA,sBAAsBX,GAC5C/R,KAAKiS,4BAA4B,IAAId,GAAoBe,GAAmBC,qEAO5EP,EAAAzR,UAAA,4BAAc,OAAOH,KAAK4S,gBAC9B,SAAcb,GACZ/R,KAAK4S,WAAaF,EAAAA,sBAAsBX,0DAMtCH,EAAAzR,UAAA,iCAAmB,OAAOH,KAAK6S,qBACnC,SAAmBd,GACjB/R,KAAK8S,wBAAwBf,GACzB/R,KAAK6S,kBAAoBd,IAC3B/R,KAAK6S,gBAAkBd,EACvB/R,KAAKiS,4BAA4B,IAAId,GAAoBe,GAAmBa,wEAO5EnB,EAAAzR,UAAA,8BAAgB,OAAOH,KAAKgT,kBAChC,SAAgBjB,GACd/R,KAAKgT,aAAeN,EAAAA,sBAAsBX,0DAMxCH,EAAAzR,UAAA,mCAAqB,OAAOH,KAAKiT,uBACrC,SAAqBlB,GACnB/R,KAAKiT,kBAAoBP,EAAAA,sBAAsBX,0DAM7CH,EAAAzR,UAAA,iCAAmB,OAAOH,KAAKkT,qBACnC,SAAmBnB,GACbA,IACF/R,KAAKkT,gBAAkBnB,0DAOvBH,EAAAzR,UAAA,kCAAoB,OAAOH,KAAKmT,sBACpC,SAAoBpB,GACdA,IACF/R,KAAKmT,iBAAmBpB,oCAqD5BH,EAAAzR,UAAAiT,SAAA,WACEpT,KAAKqT,wBAGPzB,EAAAzR,UAAA2I,YAAA,WACM9I,KAAKsT,gBACPtT,KAAKsT,eAAe5B,WAKxBE,EAAAzR,UAAAoT,KAAA,WACE,IAAMhC,EAAe,IAAIJ,GAAoBe,GAAmBsB,MAChExT,KAAKyT,4BAA4BlC,IAInCK,EAAAzR,UAAAuT,MAAA,SAAM/R,GACJ,IAAM4P,EAAe,IAAIJ,GAAoBe,GAAmByB,MAAOhS,GACvE3B,KAAKyT,4BAA4BlC,IAInCK,EAAAzR,UAAAyT,OAAA,WACE,IAAMrC,EAAe,IAAIJ,GAAoBe,GAAmB2B,QAChE7T,KAAKyT,4BAA4BlC,IAInCK,EAAAzR,UAAA2T,OAAA,WACE,OAAO9T,KAAK+T,OAIdnC,EAAAzR,UAAA6T,cAAA,WACE,OACErS,MAAO,UACPsS,QAAUC,eAAgBlU,KAAKkU,eAAgBC,gBAAiBnU,KAAKmU,mBAKzEvC,EAAAzR,UAAAiU,iBAAA,SAAiBC,GACO,YAAlBA,EAAMC,SACRtU,KAAKuU,aACLvU,KAAKwU,UAAU5L,QACY,SAAlByL,EAAMC,UACftU,KAAKyU,gBACLzU,KAAK0U,WAAW9L,SAKpBgJ,EAAAzR,UAAAkT,qBAAA,SAAqBsB,EAAmCC,QAAnC,IAAAD,IAAAA,EAAa3U,KAAKoS,sBAAiB,IAAAwC,IAAAA,EAAY5U,KAAKuS,eACvEvS,KAAK6U,WAAW,sBAAuC,WAAfF,GAA0C,QAAfA,EACnE3U,KAAK6U,WAAW,qBAAuC,UAAfF,GAAyC,UAAfA,EAElE3U,KAAK6U,WAAW,qBAAqC,UAAdD,GAAuC,QAAdA,EAChE5U,KAAK6U,WAAW,qBAAqC,UAAdD,GAAuC,UAAdA,EAEhE5U,KAAK6U,WAAW,sBAAuC,WAAfF,GAAyC,WAAdC,GAI7DhD,EAAAzR,UAAAoU,sBACNvU,KAAK8U,gCAGA9U,KAAK+U,qBAIL/U,KAAKgV,YAAchV,KAAK+U,oBAC3B/U,KAAKgV,WAAahV,KAAK6R,kBAAkBxR,OAAOL,KAAK+U,kBAAkBE,gBAGrEjV,KAAKkV,WACPlV,KAAKgV,WAAWG,iCAKZvD,EAAAzR,UAAAsU,yBACN,IAAMW,EAAUpV,KAAKqV,0BAGjBD,GAAW,UAAWA,GACxBpV,KAAKqV,0BAA0BC,QAGjCtV,KAAKqV,0BAA4B,KAE7BrV,KAAKgV,aACPhV,KAAKgV,WAAWO,UAChBvV,KAAKgV,gBAAa7M,IAKdyJ,EAAAzR,UAAA2U,yCACF9U,KAAKwH,YACPxH,KAAKqV,0BAA4BrV,KAAKwH,UAAsC,gBAKxEoK,EAAAzR,UAAA8R,qCAA4BV,GAC9BvR,KAAKsT,gBACPtT,KAAKsT,eAAehC,SAASC,IAKzBK,EAAAzR,UAAAsT,qCAA4BlC,GAClC,IAAKvR,KAAKsT,eACR,MAAMzO,IAGR7E,KAAKsT,eAAehC,SAASC,IAIvBK,EAAAzR,UAAA6R,kCAAyBwD,GAC/B,IAAwC,IAApCvQ,GAAkByB,QAAQ8O,GAC5B,MAAM1Q,EAA+B0Q,IAKjC5D,EAAAzR,UAAAmS,gCAAuBkD,GAC7B,IAAuC,IAAnCrQ,GAAiBuB,QAAQ8O,GAC3B,MAAMtQ,EAA6BsQ,IAK/B5D,EAAAzR,UAAA2S,iCAAwBzN,GAC9B,IAAwC,IAApCC,GAAaoB,QAAQrB,GACvB,MAAMD,EAA8BC,wBAxTzCoQ,EAAAA,UAASvN,OACRc,SAAU,cACV0M,cAAeC,EAAAA,kBAAkBC,KACjCC,YAAahM,IACbiM,QAAS,o9FACTC,SAAA,qRAnCkBC,EAAAA,iDAyMf3N,EAAAA,WAAQL,KAAIM,EAAAA,OAAMJ,MAACZ,EAAAA,wDAjKrBkC,EAAAA,sBAYAA,EAAAA,6BAKAA,EAAAA,sBAYAA,EAAAA,8BAKAA,EAAAA,6BAeAA,EAAAA,yBAYAA,EAAAA,8BAQAA,EAAAA,2BAYAA,EAAAA,gCAQAA,EAAAA,8BAQAA,EAAAA,+BAUAA,EAAAA,6BAUAA,EAAAA,sBAGAD,EAAAA,uBAGAA,EAAAA,0BAGAA,EAAAA,2BAGAA,EAAAA,gCAGAA,EAAAA,+BAGAA,EAAAA,6BAGA0M,EAAAA,UAAS/N,MAACgO,EAAAA,wCAYVD,EAAAA,UAAS/N,MAAC,4BCnJXiO,GAAA,2BACoBnW,KAAAoW,UAAAA,yCAIU,SAAAtU,EAAAiC,gEAL9B,GAcgCsS,GAAA,SAAatL,qBAKzB,IAAAC,EAAAD,EAAAE,KAAAjL,KAA+C6C,IAAA7C,YAC/CgL,EAAAoL,UAAAA,EAJpBpL,EAAAwE,QAAkBA,qBAElBrE,EAAAA,EAAAA,iCAUE,IAAIzI,8EAIF1C,KAAA6C,YAAA7B,MAAAkC,GAGAR,+BArB4B,KCXhC4T,GAAA,0BAA0ErV,GACtDjB,KAAAe,eAAwBA,EACxBf,KAAAgB,MAAQA,2BAGnBb,UAAA8K,KAAiB,SAAAnJ,EAAAiC,iFAL1B,GAe6BwS,GAAA,SAAaxL,gBAahCwC,EAAAvM,EAAAC,GAVF,IAAA+J,EAAAD,EAAAE,KAAAjL,KAAA6C,IAAA7C,YAEAgL,EAAAwL,SAAAC,EAEAzL,EAAA0L,UAAYD,EAOhBzL,EAAK2L,aAAYF,EACjBzL,EAAK0L,UAAY1V,GAAAyV,EACjBzL,EAAA2L,aAAA1V,GAA6BwV,EAC3B3K,EAAAyB,IACAvC,EAAKwC,SAAWxC,gBAEZuC,IACJvC,EAAKwC,SAAWD,EAChBvC,EAAKwL,SAAAjJ,EAA0BnL,MAAAqU,EAC/BzL,EAAK0L,UAAYnJ,EAAAvM,OAAAyV,yCAdvBtL,EAAAA,EAAAA,8FAuBInL,KAAA6C,YAAA7B,MAAAkC,0HAUAlD,KAAA6C,YAAA7B,MAAAkC,8HAUAlD,KAAA6C,YAAA7B,MAAAkC,yCApDyB,K1B1B7B0T,GAAA,sBAAyBC,MACvB7W,KAAI6W,MAAAA,EACF7W,KAAA6W,MAAU,uCAKW,SAAA/U,EAAAiC,+CAPzB,GAgB8B+S,GAAA,SAAa/L,mBAGK,IAAAC,EAAAD,EAAKE,KAAAjL,KAAA6C,IAAA7C,YAF7CgL,EAAA6L,MAAgBA,qBAExB1L,EAAAA,EAAAA,iCAME,IAAM0L,EAAQ7W,KAAA6W,MACVjR,IAAK5F,KAAS4F,MAChBA,GAAKiR,IACL7W,KAAI6C,YAAAT,KAAiBT,GACnBiE,IAAKiR,IACL7W,KAAK6C,YAAW5B,mCAdQ,K2BlB9B8V,GAA6C,4DAIlB9L,KAAA,SAAAnJ,EAAAiC,GACzB,IAAMiT,EAAA,IAAAC,GAAAnV,GACFoV,EAAoB1U,EAAAwU,EAAAhX,KAAAmX,iBACtBD,IAAwBA,EAAsB7U,QAC9C2U,EAAA9U,IAAwBgV,wBAR5B,GAmBsCD,GAAA,SAAqBlM,cAGnDlI,sCADRsI,EAAAA,EAAAA,KAOkBhL,UAAAuP,WAAA,SAAA/M,EAAAgN,EAAA/M,EAAAgN,EAAAC,8DAToB,K1BpExCuH,GAAA,WAoFE,SAAAA,EACUC,EACAC,EACY/O,GAFZvI,KAAAqX,SAAAA,EACArX,KAAAsX,QAAAA,EACYtX,KAAAuI,KAAAA,qBAtCN,IAAIqG,sBAGJ,IAAIA,sBA2BG,kBAGF,IAAIA,UAQzBwI,EAAAjX,UAAA2I,YAAA,WAGE9I,KAAKuX,kBAGDvX,KAAKwX,4BACPxX,KAAKwX,2BAA2BjM,cAE9BvL,KAAKyX,6BACPzX,KAAKyX,4BAA4BlM,cAEnCvL,KAAK0X,WAAWtV,OAChBpC,KAAK0X,WAAWzW,WAEhBjB,KAAK2X,cAAc1W,WACnBjB,KAAK4X,cAAc3W,YAIrBmW,EAAAjX,UAAA0X,OAAA,SAAOC,EAAqBC,EAAoCF,GAE9D7X,KAAKuX,kBAGLvX,KAAKgY,SAAWF,EAChB9X,KAAKiY,kBAAoBF,EACzB/X,KAAKkY,QAAUL,EAIf7X,KAAKgY,SAAS1E,eAAiBtT,KAAKsT,eAAiB,IAAIjC,GACzDrR,KAAKmY,6BAIPf,EAAAjX,UAAAiY,cAAA,WACE,OAAOpY,KAAKqY,cAIdjB,EAAAjX,UAAAmY,cAAA,WACE,OAAOtY,KAAKqY,aAAerY,KAAKuY,eAAiBvY,KAAKwY,eAIxDpB,EAAAjX,UAAAqY,YAAA,WACOxY,KAAKqY,eACRrY,KAAKyY,gBACLzY,KAAK0Y,uBACL1Y,KAAK2Y,qBACL3Y,KAAK4Y,0BACL5Y,KAAK6Y,qBAKTzB,EAAAjX,UAAAoY,aAAA,SAAa5W,GACP3B,KAAK8Y,cACP9Y,KAAK+Y,iBAAiBpX,GACtB3B,KAAK8Y,YAAYE,WAKrB5B,EAAAjX,UAAAsY,cAAA,WAEE,IAAKzY,KAAK8Y,YAAa,CACrB9Y,KAAKiZ,QAAU,IAAIC,EAAAA,eAAelZ,KAAKgY,SAASmB,aAAcnZ,KAAKiY,mBAEnE,IAAMmB,GACJhH,gBAAiBpS,KAAKgY,SAAS5F,gBAC/BG,cAAevS,KAAKgY,SAASzF,cAC7B8G,YAAarZ,KAAKgY,SAASqB,YAC3BC,cAAetZ,KAAKgY,SAASsB,cAC7BC,eAAgBvZ,KAAKgY,SAASuB,eAC9BC,eAAgBxZ,KAAKgY,SAASwB,eAC9BC,cAAezZ,KAAKgY,SAASyB,eAGzBC,EAAgB1Z,KAAK2Z,kBAAkBP,EAAepZ,KAAKkY,SAEjElY,KAAK4Z,4BAA4BF,EAA2D,kBAE5F1Z,KAAK8Y,YAAc9Y,KAAKqX,SAAShX,OAAOqZ,GAK1C,OADA1Z,KAAK8Y,YAAYe,OAAO7Z,KAAKiZ,SACtBjZ,KAAK8Y,aAKN1B,EAAAjX,UAAAoX,2BACFvX,KAAK8Y,cACP9Y,KAAK8Y,YAAYpH,UACjB1R,KAAK8Y,YAAc,OAQf1B,EAAAjX,UAAA2Z,gDACF9Z,KAAKoY,iBAAmBpY,KAAK8Y,YAC/B9Y,KAAK8Y,YAAYiB,cAAc/V,KAC7BgW,EAAK,GACLC,EAAUja,KAAK0X,aACf5J,UAAU,WAAM,OAAA9C,EAAKuM,oBAEvBvX,KAAKuX,mBAQDH,EAAAjX,UAAAgY,gDACFnY,KAAKwX,4BACPxX,KAAKwX,2BAA2BjM,cAGlCvL,KAAKwX,2BAA6BxX,KAAKsT,eAAe7B,SACnD3D,UAAU,SAAAuG,GACT,OAAQA,EAAMjD,QACZ,KAAKc,GAAmBsB,KACtBxI,EAAKwN,cACL,MACF,KAAKtG,GAAmByB,MACtB3I,EAAKuN,aAAalE,EAAM1S,OACxB,MACF,KAAKuQ,GAAmB2B,OACtB7I,EAAKsN,gBACL,MACF,KAAKpG,GAAmBC,WAExB,KAAKD,GAAmBa,cACtB/H,EAAK8O,gCAOP1C,EAAAjX,UAAAuY,2CACN1Y,KAAK8Y,YACFoB,gBACAlW,KACCmW,EAAI,WAAM,OAAAnP,EAAKgN,SAASoC,gBAAgBxR,SACxCyR,EAAO,WAAM,OAAArP,EAAKgN,SAASsC,mBAC3BL,EAAUja,KAAK4X,eACfqC,EAAUja,KAAK0X,aAEhB5J,UAAU,WAAM,OAAA9C,EAAKuN,kBAIlBnB,EAAAjX,UAAAwY,yCACN3Y,KAAK8Y,YACFyB,gBACAvW,KACCmW,EAAI,SAAA9F,GAAS,OAAArJ,EAAKgN,SAASwC,eAAe5R,KAAKyL,KAC/CgG,EAAO,SAAAhG,GAAS,OAAAA,EAAMoG,UAAYC,EAAAA,SAClCL,EAAO,WAAM,OAAArP,EAAKgN,SAASsC,mBAC3BL,EAAUja,KAAK4X,eACfqC,EAAUja,KAAK0X,aAEhB5J,UAAU,WAAM,OAAA9C,EAAKuN,kBAIlBnB,EAAAjX,UAAAyY,8CACN5Y,KAAK8Y,YACFiB,cACA/V,KAAKiW,EAAUja,KAAK0X,aACpB5J,UAAU,WAAM,OAAA9C,EAAK+N,sBAIlB3B,EAAAjX,UAAA0Y,4BACD7Y,KAAKqY,eACRrY,KAAKgY,SAASjE,MAAQ/T,KAAKqY,cAAe,EAE1CrY,KAAK2X,cAAcvV,OACnBpC,KAAKgY,SAAS2C,OAAO/R,SAKjBwO,EAAAjX,UAAA4Y,0BAAiBpX,GACnB3B,KAAKqY,eACPrY,KAAKgY,SAASjE,MAAQ/T,KAAKqY,cAAe,EAE1CrY,KAAK4X,cAAcxV,KAAKT,GACxB3B,KAAKgY,SAAS3V,OAAOuG,KAAKjH,KAKtByV,EAAAjX,UAAAya,yBACN,OAAO5a,KAAKuI,MAA4B,QAApBvI,KAAKuI,KAAK5G,MAAkB,MAAQ,OAIlDyV,EAAAjX,UAAAwZ,2BAAkB/O,EAAuBiN,GAC/C,OAAO,IAAIgD,EAAAA,eACTC,iBAAkB9a,KAAK+a,qBACrBnQ,EAAOwH,gBACPxH,EAAO2H,cACP3H,EAAO4O,eACP5O,EAAO6O,cACP5B,GAEFwB,YAAazO,EAAOyO,YACpBC,cAAe1O,EAAO0O,eAAiB,mCACvCC,eAAgBvZ,KAAKgb,2BAA2BpQ,EAAO2O,gBACvD0B,UAAWjb,KAAK4a,mBAQZxD,EAAAjX,UAAAyZ,qCAA4BsB,cAC9Blb,KAAKyX,6BACPzX,KAAKyX,4BAA4BlM,cAGnCvL,KAAKyX,4BAA8ByD,EAASC,iBACzCnX,KAAKiW,EAAUja,KAAK0X,aACpB5J,UAAU,SAAArG,GAETuD,EAAKsM,QAAQ8D,IAAI,WACfpQ,EAAKgN,SAAS3E,qBACZxN,EAA8B4B,EAAO4T,eAAenV,UACpDH,EAA4B0B,EAAO4T,eAAehV,gBAOpD+Q,EAAAjX,UAAA6a,oCAA2B3V,GACjC,OAAQA,GACN,IAAK,QACH,OAAOrF,KAAKqX,SAASiE,iBAAiBC,QACxC,IAAK,aACH,OAAOvb,KAAKqX,SAASiE,iBAAiBE,aACxC,IAAK,QACH,OAAOxb,KAAKqX,SAASiE,iBAAiB5H,QACxC,IAAK,OACL,QACE,OAAO1T,KAAKqX,SAASiE,iBAAiB7E,SAKpCW,EAAAjX,UAAA4a,8BACNU,EACAC,EACAlC,EACAC,EACA5B,GAGA,IAAApM,EAAAzF,EAAAyV,GAAOxV,EAAAwF,EAAAxF,QAASC,EAAAuF,EAAAvF,SAChByV,EAAAxV,EAAAuV,GAAOtV,EAAAuV,EAAAvV,QAASC,EAAAsV,EAAAtV,SACVhB,EAAWrF,KAAKqX,SAAS6D,WAC5BU,YAAY/D,GAAS5R,QAAOA,EAAEG,QAAOA,IAAIF,SAAQA,EAAEG,SAAQA,IAC3DwV,cAAc7b,KAAK4a,iBACnBkB,mBAAmBrC,GAOtB,OAJKD,GACHxZ,KAAK+b,cAAc1W,EAAUoW,EAAkBC,GAG1CrW,GAID+R,EAAAjX,UAAA4b,uBACN1W,EACA2W,EACAC,cAGMC,EAAuC,WAAZF,GAAoC,UAAZA,EACnDG,EAAqC,UAAZF,GAAmC,UAAZA,EAIhDG,EAA+BF,GAClC,SAAU,QAAS,SAAU,MAAO,UACpC,SAAU,SACPG,EAA6BF,GAChC,QAAS,QAAS,SAAU,MAAO,UACnC,QAAS,SAGNG,KACNhW,EAAuB0V,EAASI,GAA8BlO,QAAQ,SAAApI,GACpEQ,EAAuB2V,EAASI,GAA4BnO,QAAQ,SAAAxI,GAClE4W,EAAUtV,MAAMlB,EAACA,EAAEJ,EAACA,QAKxB4W,EAAUzV,MAAM,EAAGyV,EAAUjb,QAC1B6M,QAAQ,SAACzC,OAAC3F,EAAA2F,EAAA3F,EAAGJ,EAAA+F,EAAA/F,EAAO,OAAAsF,EAAKuR,eAAelX,EAAUS,EAAGJ,MAOlD0R,EAAAjX,UAAAoc,wBAAelX,EAAU+M,EAAiBG,GAChD,IAAA9G,EAAAzF,EAAAoM,GAAOnM,EAAAwF,EAAAxF,QAASC,EAAAuF,EAAAvF,SAChByV,EAAAxV,EAAAoM,GAAOnM,EAAAuV,EAAAvV,QAASC,EAAAsV,EAAAtV,SAChBhB,EAASmX,sBAAsBvW,QAAOA,EAAEG,QAAOA,IAAIF,SAAQA,EAAEG,SAAQA,yBAhXxE4B,EAAAA,sDAlCCwU,EAAAA,eARAC,EAAAA,cAcOnV,GAAca,aAAAJ,KAsElBK,EAAAA,gBAvFL,G2BAAsU,GAAA,WAiDE,SAAAA,EACUC,EACA3E,EACD4E,GAFC7c,KAAA4c,YAAAA,EACA5c,KAAAiY,kBAAAA,EACDjY,KAAA6c,WAAAA,qBAhBiB,IAAInV,EAAAA,gCAGJ,IAAIA,EAAAA,6BAQT,IAAIkH,gCArBrB+N,EAAAxc,UAAA,kCAAoB,OAAOH,KAAK8c,sBACpC,SAAoBnb,GAClB3B,KAAK+c,yBAAyBpb,GAC9B3B,KAAK8c,iBAAmBnb,EAExB3B,KAAK6c,WAAWhF,OAAO7X,KAAKgd,gBAAiBhd,KAAKiY,kBAAmBjY,KAAK4c,8CAW5ED,EAAAxc,UAAAiY,cAAA,WACE,OAAOpY,KAAK6c,WAAWzE,iBAYzBuE,EAAAxc,UAAAiT,SAAA,WAAA,IAAApI,EAAAhL,KAMEid,EAJgBjd,KAAK6c,WAAWlF,cAC7B3T,KAAKmW,EAAI,WAAM,OAAAnP,EAAK2M,cAAc/O,UACrB5I,KAAK6c,WAAWjF,cAC7B5T,KAAKmW,EAAI,SAAAxY,GAAS,OAAAqJ,EAAK4M,cAAchP,KAAKjH,OACrBqC,KAAKiW,EAAUja,KAAK0X,aAAa5J,aAG3D6O,EAAAxc,UAAA2I,YAAA,WACE9I,KAAK0X,WAAWtV,OAChBpC,KAAK0X,WAAWzW,YAIlB0b,EAAAxc,UAAAmY,cAAA,WACEtY,KAAK6c,WAAWvE,iBAIlBqE,EAAAxc,UAAAqY,YAAA,WACExY,KAAK6c,WAAWrE,eAIlBmE,EAAAxc,UAAAoY,aAAA,SAAa5W,GACX3B,KAAK6c,WAAWtE,aAAa5W,IAIvBgb,EAAAxc,UAAA4c,kCAAyBjF,GAC/B,KAAKA,GAAaA,aAAmBlG,IACnC,MAAMjN,yBAtEXoE,EAAAA,UAASb,OACRc,SAAU,wBACVM,SAAU,mBACVL,WAAYmO,iDAlBZ8F,EAAAA,kBAMAC,EAAAA,wBAOO/F,+CAUN5N,EAAAA,MAAKtB,MAAC,8CAWNqB,EAAAA,8BAGAA,EAAAA,YAvCH,GCAA6T,GAAA,oDASC3T,EAAAA,SAAQvB,OACPmV,SACEC,EAAAA,aACAC,EAAAA,cACAC,EAAAA,WACA5T,IAEFD,cACEiI,GACA+K,IAEFjT,SACEkI,GACA+K,GACA/S,UAvBJ","file":"sat-popover.umd.min.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parent: Subscription = null;\n  /** @internal */\n  protected _parents: Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  /** @internal */\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic } from './types';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from '../internal/symbol/observable';\nimport { OperatorFunction, PartialObserver, Subscribable } from '../internal/types';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * The same Observable instance returned by any call to {@link empty} without a\n * {@link Scheduler}. It is preferrable to use this over `empty()`.\n */\nexport const EMPTY = new Observable<never>(subscriber => subscriber.complete());\n\n/**\n * Creates an Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.\n * </span>\n *\n * <img src=\"./img/empty.png\" width=\"100%\">\n *\n * This static operator is useful for creating a simple Observable that only\n * emits the complete notification. It can be used for composing with other\n * Observables, such as in a {@link mergeMap}.\n *\n * @example <caption>Emit the number 7, then complete.</caption>\n * var result = Rx.Observable.empty().startWith(7);\n * result.subscribe(x => console.log(x));\n *\n * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n * var interval = Rx.Observable.interval(1000);\n * var result = interval.mergeMap(x =>\n *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval eg(0,1,2,3,...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1 print abc\n * // if x % 2 is not equal to 1 nothing will be output\n *\n * @see {@link create}\n * @see {@link never}\n * @see {@link of}\n * @see {@link throw}\n *\n * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n * the emission of the complete notification.\n * @return {Observable} An \"empty\" Observable: emits only the complete\n * notification.\n * @static true\n * @name empty\n * @owner Observable\n * @deprecated Deprecated in favor of using EMPTY constant.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nexport function emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>(subscriber => scheduler.schedule(() => subscriber.complete()));\n}\n","import { SchedulerLike } from '../types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToArray } from '../util/subscribeToArray';\n\nexport function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToArray(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let i = 0;\n      sub.add(scheduler.schedule(function () {\n        if (i === input.length) {\n          subscriber.complete();\n          return;\n        }\n        subscriber.next(input[i++]);\n        if (!subscriber.closed) {\n          sub.add(this.schedule());\n        }\n      }));\n      return sub;\n    });\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","export function isPromise(value: any): value is PromiseLike<any> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","\nimport { ObservableInput } from '../types';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeTo } from './subscribeTo';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription | void {\n  const destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  return subscribeTo(result)(destination);\n}\n","import { ObservableLike } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isObservable(input: any): input is ObservableLike<any> {\n  return input && typeof input[Symbol_observable] === 'function';\n}\n","import { iterator as Symbol_iterator } from '../symbol/iterator';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return input && typeof input[Symbol_iterator] === 'function';\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { subscribeToPromise } from '../util/subscribeToPromise';\n\nexport function fromPromise<T>(input: PromiseLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToPromise(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      sub.add(scheduler.schedule(() => input.then(\n        value => {\n          sub.add(scheduler.schedule(() => {\n            subscriber.next(value);\n            sub.add(scheduler.schedule(() => subscriber.complete()));\n          }));\n        },\n        err => {\n          sub.add(scheduler.schedule(() => subscriber.error(err)));\n        }\n      )));\n      return sub;\n    });\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { subscribeToIterable } from '../util/subscribeToIterable';\n\nexport function fromIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  if (!scheduler) {\n    return new Observable<T>(subscribeToIterable(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      let iterator: Iterator<T>;\n      sub.add(() => {\n        // Finalize generators\n        if (iterator && typeof iterator.return === 'function') {\n          iterator.return();\n        }\n      });\n      sub.add(scheduler.schedule(() => {\n        iterator = input[Symbol_iterator]();\n        sub.add(scheduler.schedule(function () {\n          if (subscriber.closed) {\n            return;\n          }\n          let value: T;\n          let done: boolean;\n          try {\n            const result = iterator.next();\n            value = result.value;\n            done = result.done;\n          } catch (err) {\n            subscriber.error(err);\n            return;\n          }\n          if (done) {\n            subscriber.complete();\n          } else {\n            subscriber.next(value);\n            this.schedule();\n          }\n        }));\n      }));\n      return sub;\n    });\n  }\n}\n","import { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { subscribeToObservable } from '../util/subscribeToObservable';\nimport { ObservableLike, SchedulerLike, Subscribable } from '../types';\n\nexport function fromObservable<T>(input: ObservableLike<T>, scheduler: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToObservable(input));\n  } else {\n    return new Observable<T>(subscriber => {\n      const sub = new Subscription();\n      sub.add(scheduler.schedule(() => {\n        const observable: Subscribable<T> = input[Symbol_observable]();\n        sub.add(observable.subscribe({\n          next(value) { sub.add(scheduler.schedule(() => subscriber.next(value))); },\n          error(err) { sub.add(scheduler.schedule(() => subscriber.error(err))); },\n          complete() { sub.add(scheduler.schedule(() => subscriber.complete())); },\n        }));\n      }));\n      return sub;\n    });\n  }\n}\n","import { Observable } from '../Observable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isObservable } from '../util/isObservable';\nimport { isIterable } from '../util/isIterable';\nimport { fromArray } from './fromArray';\nimport { fromPromise } from './fromPromise';\nimport { fromIterable } from './fromIterable';\nimport { fromObservable } from './fromObservable';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { ObservableInput, SchedulerLike } from '../types';\n\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport function from<T>(input: ObservableInput<ObservableInput<T>>, scheduler?: SchedulerLike): Observable<Observable<T>>;\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  if (!scheduler) {\n    if (input instanceof Observable) {\n      return input;\n    }\n    return new Observable(subscribeTo(input));\n  }\n\n  if (input != null) {\n    if (isObservable(input)) {\n      return fromObservable(input, scheduler);\n    } else if (isPromise(input)) {\n      return fromPromise(input, scheduler);\n    } else if (isArrayLike(input)) {\n      return fromArray(input, scheduler);\n    }  else if (isIterable(input) || typeof input === 'string') {\n      return fromIterable(input, scheduler);\n    }\n  }\n\n  throw new TypeError((input !== null && typeof input || input) + ' is not observable');\n}\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, R>(project: (value: T, index: number) => ObservableInput<R>, resultSelector: undefined, concurrent?: number): OperatorFunction<T, R>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * <img src=\"./img/mergeMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n * var letters = Rx.Observable.of('a', 'b', 'c');\n * var result = letters.mergeMap(x =>\n *   Rx.Observable.interval(1000).map(i => x+i)\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and merging the results of the Observables obtained\n * from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: ((outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, I|R> {\n  if (typeof resultSelector === 'function') {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      mergeMap((a, i) => from(project(a, i)).pipe(\n        map((b, ii) => resultSelector(a, b, i, ii)),\n      ), concurrent)\n    );\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return (source: Observable<T>) => source.lift(new MergeMapOperator(project, concurrent));\n}\n\nexport class MergeMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<R>, value: T, index: number): void {\n    this.add(subscribeToResult<T, R>(this, ish, value, index));\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","\nimport { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { MonoTypeOperatorFunction, OperatorFunction, ObservableInput } from '../types';\n\nexport function mergeAll<T>(concurrent?: number): OperatorFunction<ObservableInput<T>, T>;\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nexport function mergeAll<T>(concurrent: number = Number.POSITIVE_INFINITY): MonoTypeOperatorFunction<T> {\n  return mergeMap<T, T>(identity as (value: T, index: number) => ObservableInput<T>, concurrent);\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike} from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\nimport { fromArray } from './fromArray';\n\n/* tslint:disable:max-line-length */\nexport function merge<T>(v1: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>;\nexport function merge<T>(v1: ObservableInput<T>, concurrent?: number, scheduler?: SchedulerLike): Observable<T>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number, scheduler?: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;\nexport function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * <img src=\"./img/merge.png\" width=\"100%\">\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var timer = Rx.Observable.interval(1000);\n * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n *\n * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var concurrent = 2; // the argument\n * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): Observable<R> {\n let concurrent = Number.POSITIVE_INFINITY;\n let scheduler: SchedulerLike = null;\n  let last: any = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = <SchedulerLike>observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = <number>observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = <number>observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return <Observable<R>>observables[0];\n  }\n\n  return mergeAll<R>(concurrent)(fromArray<any>(observables, scheduler));\n}\n","import { VALID_HORIZ_ALIGN, VALID_VERT_ALIGN, VALID_SCROLL } from './popover.component';\n\nexport function getInvalidPopoverError(): Error {\n  return Error('SatPopoverAnchor must be provided an SatPopover component instance.');\n}\n\nexport function getUnanchoredPopoverError(): Error {\n  return Error('SatPopover is not anchored to any SatPopoverAnchor.');\n}\n\nexport function getInvalidHorizontalAlignError(alignment): Error {\n  return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));\n}\n\nexport function getInvalidVerticalAlignError(alignment): Error {\n  return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));\n}\n\nexport function getInvalidScrollStrategyError(strategy): Error {\n  return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));\n}\n\nfunction generateGenericError(apiName: string, invalid: any, valid: string[]): string {\n  return `Invalid ${apiName}: '${invalid}'. Valid options are ` +\n    `${valid.map(v => `'${v}'`).join(', ')}.`;\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { empty } from '../observable/empty';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * <img src=\"./img/take.png\" width=\"100%\">\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n * var interval = Rx.Observable.interval(1000);\n * var five = interval.take(5);\n * five.subscribe(x => console.log(x));\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n *\n * @param {number} count The maximum number of `next` values to emit.\n * @return {Observable<T>} An Observable that emits only the first `count`\n * values emitted by the source Observable, or all of the values from the source\n * if the source emits fewer than `count` values.\n * @method take\n * @owner Observable\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    if (count === 0) {\n      return empty();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nclass TakeOperator<T> implements Operator<T, T> {\n  constructor(private total: number) {\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError;\n    }\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeSubscriber<T> extends Subscriber<T> {\n  private count: number = 0;\n\n  constructor(destination: Subscriber<T>, private total: number) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    const total = this.total;\n    const count = ++this.count;\n    if (count <= total) {\n      this.destination.next(value);\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  }\n}\n","import {\n  ElementRef,\n  Injectable,\n  NgZone,\n  OnDestroy,\n  Optional,\n  ViewContainerRef\n} from '@angular/core';\nimport {\n  ConnectedPositionStrategy,\n  HorizontalConnectionPos,\n  Overlay,\n  OverlayRef,\n  OverlayConfig,\n  ScrollStrategy,\n  VerticalConnectionPos,\n} from '@angular/cdk/overlay';\nimport { Directionality, Direction} from '@angular/cdk/bidi';\nimport { ESCAPE } from '@angular/cdk/keycodes';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { Subscription, Subject } from 'rxjs';\nimport { takeUntil, take, filter, tap } from 'rxjs/operators';\n\nimport {\n  SatPopover,\n  SatPopoverHorizontalAlign,\n  SatPopoverVerticalAlign,\n  SatPopoverScrollStrategy,\n} from './popover.component';\nimport { PopoverNotificationService, NotificationAction } from './notification.service';\n\n/**\n * Configuration provided by the popover for the anchoring service\n * to build the correct overlay config.\n */\ninterface PopoverConfig {\n  horizontalAlign: SatPopoverHorizontalAlign;\n  verticalAlign: SatPopoverVerticalAlign;\n  hasBackdrop: boolean;\n  backdropClass: string;\n  scrollStrategy: SatPopoverScrollStrategy;\n  forceAlignment: boolean;\n  lockAlignment: boolean;\n}\n\n@Injectable()\nexport class PopoverAnchoringService implements OnDestroy {\n\n  /** Emits when the popover is opened. */\n  popoverOpened = new Subject<void>();\n\n  /** Emits when the popover is closed. */\n  popoverClosed = new Subject<void>();\n\n  /** Reference to the overlay containing the popover component. */\n  _overlayRef: OverlayRef;\n\n  /** Reference to the target popover. */\n  private _popover: SatPopover;\n\n  /** Reference to the view container for the popover template. */\n  private _viewContainerRef: ViewContainerRef;\n\n  /** Reference to the anchor element. */\n  private _anchor: ElementRef;\n\n  /** Reference to a template portal where the overlay will be attached. */\n  private _portal: TemplatePortal<any>;\n\n  /** Communications channel with the popover. */\n  private _notifications: PopoverNotificationService;\n\n  /** Single subscription to notifications service events. */\n  private _notificationsSubscription: Subscription;\n\n  /** Single subscription to position changes. */\n  private _positionChangeSubscription: Subscription;\n\n  /** Whether the popover is presently open. */\n  private _popoverOpen = false;\n\n  /** Emits when the directive is destroyed. */\n  private _onDestroy = new Subject<void>();\n\n  constructor(\n    private _overlay: Overlay,\n    private _ngZone: NgZone,\n    @Optional() private _dir: Directionality\n  ) { }\n\n  ngOnDestroy() {\n    // Destroy popover before terminating subscriptions so that any resulting\n    // detachments update 'closed state'\n    this._destroyPopover();\n\n    // Terminate subscriptions\n    if (this._notificationsSubscription) {\n      this._notificationsSubscription.unsubscribe();\n    }\n    if (this._positionChangeSubscription) {\n      this._positionChangeSubscription.unsubscribe();\n    }\n    this._onDestroy.next();\n    this._onDestroy.complete();\n\n    this.popoverOpened.complete();\n    this.popoverClosed.complete();\n  }\n\n  /** Anchor a popover instance to a view and connection element. */\n  anchor(popover: SatPopover, viewContainerRef: ViewContainerRef, anchor: ElementRef): void {\n    // Destroy any previous popovers\n    this._destroyPopover();\n\n    // Assign local refs\n    this._popover = popover;\n    this._viewContainerRef = viewContainerRef;\n    this._anchor = anchor;\n\n    // Provide notification service as a communication channel between popover and anchor.\n    // Then subscribe to notifications to take appropriate actions.\n    this._popover._notifications = this._notifications = new PopoverNotificationService();\n    this._subscribeToNotifications();\n  }\n\n  /** Gets whether the popover is presently open. */\n  isPopoverOpen(): boolean {\n    return this._popoverOpen;\n  }\n\n  /** Toggles the popover between the open and closed states. */\n  togglePopover(): void {\n    return this._popoverOpen ? this.closePopover() : this.openPopover();\n  }\n\n  /** Opens the popover. */\n  openPopover(): void {\n    if (!this._popoverOpen) {\n      this.createOverlay();\n      this._subscribeToBackdrop();\n      this._subscribeToEscape();\n      this._subscribeToDetachments();\n      this._saveOpenedState();\n    }\n  }\n\n  /** Closes the popover. */\n  closePopover(value?: any): void {\n    if (this._overlayRef) {\n      this._saveClosedState(value);\n      this._overlayRef.detach();\n    }\n  }\n\n  /** Create an overlay to be attached to the portal. */\n  createOverlay(): OverlayRef {\n    // Create overlay if it doesn't yet exist\n    if (!this._overlayRef) {\n      this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);\n\n      const popoverConfig = {\n        horizontalAlign: this._popover.horizontalAlign,\n        verticalAlign: this._popover.verticalAlign,\n        hasBackdrop: this._popover.hasBackdrop,\n        backdropClass: this._popover.backdropClass,\n        scrollStrategy: this._popover.scrollStrategy,\n        forceAlignment: this._popover.forceAlignment,\n        lockAlignment: this._popover.lockAlignment,\n      };\n\n      const overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);\n\n      this._subscribeToPositionChanges(overlayConfig.positionStrategy as ConnectedPositionStrategy);\n\n      this._overlayRef = this._overlay.create(overlayConfig);\n    }\n\n    // Actually open the popover\n    this._overlayRef.attach(this._portal);\n    return this._overlayRef;\n  }\n\n\n  /** Removes the popover from the DOM. Does NOT update open state. */\n  private _destroyPopover(): void {\n    if (this._overlayRef) {\n      this._overlayRef.dispose();\n      this._overlayRef = null;\n    }\n  }\n\n  /**\n   * Destroys the popover immediately if it is closed, or waits until it\n   * has been closed to destroy it.\n   */\n  private _destroyPopoverOnceClosed(): void {\n    if (this.isPopoverOpen() && this._overlayRef) {\n      this._overlayRef.detachments().pipe(\n        take(1),\n        takeUntil(this._onDestroy)\n      ).subscribe(() => this._destroyPopover());\n    } else {\n      this._destroyPopover();\n    }\n  }\n\n  /**\n   * Call appropriate anchor method when an event is dispatched through\n   * the notification service.\n   */\n  private _subscribeToNotifications(): void {\n    if (this._notificationsSubscription) {\n      this._notificationsSubscription.unsubscribe();\n    }\n\n    this._notificationsSubscription = this._notifications.events()\n      .subscribe(event => {\n        switch (event.action) {\n          case NotificationAction.OPEN:\n            this.openPopover();\n            break;\n          case NotificationAction.CLOSE:\n            this.closePopover(event.value);\n            break;\n          case NotificationAction.TOGGLE:\n            this.togglePopover();\n            break;\n          case NotificationAction.REPOSITION:\n            // TODO: When the overlay's position can be dynamically changed, do not destroy\n          case NotificationAction.UPDATE_CONFIG:\n            this._destroyPopoverOnceClosed();\n            break;\n        }\n      });\n  }\n\n  /** Close popover when backdrop is clicked. */\n  private _subscribeToBackdrop(): void {\n    this._overlayRef\n      .backdropClick()\n      .pipe(\n        tap(() => this._popover.backdropClicked.emit()),\n        filter(() => this._popover.interactiveClose),\n        takeUntil(this.popoverClosed),\n        takeUntil(this._onDestroy),\n      )\n      .subscribe(() => this.closePopover());\n  }\n\n  /** Close popover when escape keydown event occurs. */\n  private _subscribeToEscape(): void {\n    this._overlayRef\n      .keydownEvents()\n      .pipe(\n        tap(event => this._popover.overlayKeydown.emit(event)),\n        filter(event => event.keyCode === ESCAPE),\n        filter(() => this._popover.interactiveClose),\n        takeUntil(this.popoverClosed),\n        takeUntil(this._onDestroy),\n      )\n      .subscribe(() => this.closePopover());\n  }\n\n  /** Set state back to closed when detached. */\n  private _subscribeToDetachments(): void {\n    this._overlayRef\n      .detachments()\n      .pipe(takeUntil(this._onDestroy))\n      .subscribe(() => this._saveClosedState());\n  }\n\n  /** Save the opened state of the popover and emit. */\n  private _saveOpenedState(): void {\n    if (!this._popoverOpen) {\n      this._popover._open = this._popoverOpen = true;\n\n      this.popoverOpened.next();\n      this._popover.opened.emit();\n    }\n  }\n\n  /** Save the closed state of the popover and emit. */\n  private _saveClosedState(value?: any): void {\n    if (this._popoverOpen) {\n      this._popover._open = this._popoverOpen = false;\n\n      this.popoverClosed.next(value);\n      this._popover.closed.emit(value);\n    }\n  }\n\n  /** Gets the text direction of the containing app. */\n  private _getDirection(): Direction {\n    return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n  }\n\n  /** Create and return a config for creating the overlay. */\n  private _getOverlayConfig(config: PopoverConfig, anchor: ElementRef): OverlayConfig {\n    return new OverlayConfig({\n      positionStrategy: this._getPositionStrategy(\n        config.horizontalAlign,\n        config.verticalAlign,\n        config.forceAlignment,\n        config.lockAlignment,\n        anchor,\n      ),\n      hasBackdrop: config.hasBackdrop,\n      backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',\n      scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),\n      direction: this._getDirection(),\n    });\n  }\n\n  /**\n   * Listen to changes in the position of the overlay and set the correct alignment classes,\n   * ensuring that the animation origin is correct, even with a fallback position.\n   */\n  private _subscribeToPositionChanges(position: ConnectedPositionStrategy): void {\n    if (this._positionChangeSubscription) {\n      this._positionChangeSubscription.unsubscribe();\n    }\n\n    this._positionChangeSubscription = position.onPositionChange\n      .pipe(takeUntil(this._onDestroy))\n      .subscribe(change => {\n        // Position changes may occur outside the Angular zone\n        this._ngZone.run(() => {\n          this._popover._setAlignmentClasses(\n            getHorizontalPopoverAlignment(change.connectionPair.overlayX),\n            getVerticalPopoverAlignment(change.connectionPair.overlayY),\n          );\n        });\n      });\n  }\n\n  /** Map a scroll strategy string type to an instance of a scroll strategy. */\n  private _getScrollStrategyInstance(strategy: SatPopoverScrollStrategy): ScrollStrategy {\n    switch (strategy) {\n      case 'block':\n        return this._overlay.scrollStrategies.block();\n      case 'reposition':\n        return this._overlay.scrollStrategies.reposition();\n      case 'close':\n        return this._overlay.scrollStrategies.close();\n      case 'noop':\n      default:\n        return this._overlay.scrollStrategies.noop();\n    }\n  }\n\n  /** Create and return a position strategy based on config provided to the component instance. */\n  private _getPositionStrategy(\n    horizontalTarget: SatPopoverHorizontalAlign,\n    verticalTarget: SatPopoverVerticalAlign,\n    forceAlignment: boolean,\n    lockAlignment: boolean,\n    anchor: ElementRef,\n  ): ConnectedPositionStrategy {\n    // Attach the overlay at the preferred position\n    const {originX, overlayX} = getHorizontalConnectionPosPair(horizontalTarget);\n    const {originY, overlayY} = getVerticalConnectionPosPair(verticalTarget);\n    const strategy = this._overlay.position()\n      .connectedTo(anchor, {originX, originY}, {overlayX, overlayY})\n      .withDirection(this._getDirection())\n      .withLockedPosition(lockAlignment);\n\n    // Unless the alignment is forced, add fallbacks based on the preferred positions\n    if (!forceAlignment) {\n      this._addFallbacks(strategy, horizontalTarget, verticalTarget);\n    }\n\n    return strategy;\n  }\n\n  /** Add fallbacks to a given strategy based around target alignments. */\n  private _addFallbacks(\n    strategy: ConnectedPositionStrategy,\n    hTarget: SatPopoverHorizontalAlign,\n    vTarget: SatPopoverVerticalAlign\n  ): void {\n    // Determine if the target alignments overlap the anchor\n    const horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';\n    const verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';\n\n    // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments\n    // cover the anchor\n    const possibleHorizontalAlignments = horizontalOverlapAllowed ?\n      ['before', 'start', 'center', 'end', 'after'] :\n      ['before', 'after'];\n    const possibleVerticalAlignments = verticalOverlapAllowed ?\n      ['above', 'start', 'center', 'end', 'below'] :\n      ['above', 'below'];\n\n    // Create fallbacks for each allowed prioritized fallback alignment combo\n    const fallbacks = [];\n    prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(h => {\n      prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(v => {\n        fallbacks.push({h, v});\n      });\n    });\n\n    // Remove the first fallback since it will be the target alignment that is already applied\n    fallbacks.slice(1, fallbacks.length)\n      .forEach(({h, v}) => this._applyFallback(strategy, h, v));\n  }\n\n  /**\n  * Convert a specific horizontal and vertical alignment into a fallback and apply it to\n  * the strategy.\n  */\n  private _applyFallback(strategy, horizontalAlign, verticalAlign): void {\n    const {originX, overlayX} = getHorizontalConnectionPosPair(horizontalAlign);\n    const {originY, overlayY} = getVerticalConnectionPosPair(verticalAlign);\n    strategy.withFallbackPosition({originX, originY}, {overlayX, overlayY});\n  }\n\n\n}\n\n/** Helper function to convert an overlay connection position to equivalent popover alignment. */\nfunction getHorizontalPopoverAlignment(h: HorizontalConnectionPos): SatPopoverHorizontalAlign {\n  if (h === 'start') {\n    return 'after';\n  }\n\n  if (h === 'end') {\n    return 'before';\n  }\n\n  return 'center';\n}\n\n/** Helper function to convert an overlay connection position to equivalent popover alignment. */\nfunction getVerticalPopoverAlignment(v: VerticalConnectionPos): SatPopoverVerticalAlign {\n  if (v === 'top') {\n    return 'below';\n  }\n\n  if (v === 'bottom') {\n    return 'above';\n  }\n\n  return 'center';\n}\n\n/** Helper function to convert alignment to origin/overlay position pair. */\nfunction getHorizontalConnectionPosPair(h: SatPopoverHorizontalAlign):\n    {originX: HorizontalConnectionPos, overlayX: HorizontalConnectionPos} {\n  switch (h) {\n    case 'before':\n      return {originX: 'start', overlayX: 'end'};\n    case 'start':\n      return {originX: 'start', overlayX: 'start'};\n    case 'end':\n      return {originX: 'end', overlayX: 'end'};\n    case 'after':\n      return {originX: 'end', overlayX: 'start'};\n    default:\n      return {originX: 'center', overlayX: 'center'};\n  }\n}\n\n/** Helper function to convert alignment to origin/overlay position pair. */\nfunction getVerticalConnectionPosPair(v: SatPopoverVerticalAlign):\n    {originY: VerticalConnectionPos, overlayY: VerticalConnectionPos} {\n  switch (v) {\n    case 'above':\n      return {originY: 'top', overlayY: 'bottom'};\n    case 'start':\n      return {originY: 'top', overlayY: 'top'};\n    case 'end':\n      return {originY: 'bottom', overlayY: 'bottom'};\n    case 'below':\n      return {originY: 'bottom', overlayY: 'top'};\n    default:\n      return {originY: 'center', overlayY: 'center'};\n  }\n}\n\n\n/**\n * Helper function that takes an ordered array options and returns a reorderded\n * array around the target item. e.g.:\n *\n * target: 3; options: [1, 2, 3, 4, 5, 6, 7];\n *\n * return: [3, 4, 2, 5, 1, 6, 7]\n */\nfunction prioritizeAroundTarget<T>(target: T, options: T[]): T[] {\n  const targetIndex = options.indexOf(target);\n\n  // Set the first item to be the target\n  const reordered = [target];\n\n  // Make left and right stacks where the highest priority item is last\n  const left = options.slice(0, targetIndex);\n  const right = options.slice(targetIndex + 1, options.length).reverse();\n\n  // Alternate between stacks until one is empty\n  while (left.length && right.length) {\n    reordered.push(right.pop());\n    reordered.push(left.pop());\n  }\n\n  // Flush out right side\n  while (right.length) {\n    reordered.push(right.pop());\n  }\n\n  // Flush out left side\n  while (left.length) {\n    reordered.push(left.pop());\n  }\n\n  return reordered;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {inject, InjectionToken} from '@angular/core';\n\n\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\nexport const DIR_DOCUMENT = new InjectionToken<Document>('cdk-dir-doc', {\n  providedIn: 'root',\n  factory: () => inject(DOCUMENT),\n});\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter, Inject, Injectable, Optional} from '@angular/core';\nimport {DIR_DOCUMENT} from './dir-document-token';\n\n\nexport type Direction = 'ltr' | 'rtl';\n\n\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\n@Injectable({providedIn: 'root'})\nexport class Directionality {\n  /** The current 'ltr' or 'rtl' value. */\n  readonly value: Direction = 'ltr';\n\n  /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n  readonly change = new EventEmitter<Direction>();\n\n  constructor(@Optional() @Inject(DIR_DOCUMENT) _document?: any) {\n    if (_document) {\n      // TODO: handle 'auto' value -\n      // We still need to account for dir=\"auto\".\n      // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n      // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n      const bodyDir = _document.body ? _document.body.dir : null;\n      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n      this.value = (bodyDir || htmlDir || 'ltr') as Direction;\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {\n  Directive,\n  Output,\n  Input,\n  EventEmitter,\n  AfterContentInit,\n  OnDestroy,\n} from '@angular/core';\n\nimport {Direction, Directionality} from './directionality';\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\n@Directive({\n  selector: '[dir]',\n  providers: [{provide: Directionality, useExisting: Dir}],\n  host: {'[dir]': 'dir'},\n  exportAs: 'dir',\n})\nexport class Dir implements Directionality, AfterContentInit, OnDestroy {\n  _dir: Direction = 'ltr';\n\n  /** Whether the `value` has been set to its initial value. */\n  private _isInitialized: boolean = false;\n\n  /** Event emitted when the direction changes. */\n  @Output('dirChange') change = new EventEmitter<Direction>();\n\n  /** @docs-private */\n  @Input()\n  get dir(): Direction { return this._dir; }\n  set dir(v: Direction) {\n    const old = this._dir;\n    this._dir = v;\n    if (old !== this._dir && this._isInitialized) {\n      this.change.emit(this._dir);\n    }\n  }\n\n  /** Current layout direction of the element. */\n  get value(): Direction { return this.dir; }\n\n  /** Initialize once default value has been set. */\n  ngAfterContentInit() {\n    this._isInitialized = true;\n  }\n\n  ngOnDestroy() {\n    this.change.complete();\n  }\n}\n\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {Dir} from './dir';\n\n\n@NgModule({\n  exports: [Dir],\n  declarations: [Dir],\n})\nexport class BidiModule { }\n","import {\n  trigger,\n  state,\n  style,\n  animate,\n  transition,\n  AnimationTriggerMetadata\n} from '@angular/animations';\n\nexport const transformPopover: AnimationTriggerMetadata = trigger('transformPopover', [\n  transition(':enter', [\n    style({opacity: 0, transform: 'scale(0.3)'}),\n    animate('{{openTransition}}',\n      style({opacity: 1, transform: 'scale(1)'}))\n  ]),\n  transition(':leave', [\n    animate('{{closeTransition}}',\n      style({opacity: 0, transform: 'scale(0.5)'}))\n  ])\n]);\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super(errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    this.name = 'UnsubscriptionError';\n    (Object as any).setPrototypeOf(this, UnsubscriptionError.prototype);\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): For situations where Node has multiple copies of rxjs in\n          // node_modules, we cannot rely on `instanceof` checks\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\n}\n","/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport class ObjectUnsubscribedError extends Error {\n  constructor() {\n    super('object unsubscribed');\n    this.name = 'ObjectUnsubscribedError';\n    (Object as any).setPrototypeOf(this, ObjectUnsubscribedError.prototype);\n  }\n}\n","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  if (!subscriber.closed) {\n    subscriber.complete();\n  }\n};\n","/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport class ArgumentOutOfRangeError extends Error {\n  constructor() {\n    super('argument out of range');\n    this.name = 'ArgumentOutOfRangeError';\n    (Object as any).setPrototypeOf(this, ArgumentOutOfRangeError.prototype);\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, public outerValue: T, public outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { hostReportError } from './hostReportError';\n\nexport const subscribeToPromise = <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => {\n  promise.then(\n    (value) => {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    },\n    (err: any) => subscriber.error(err)\n  )\n  .then(null, hostReportError);\n  return subscriber;\n};\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n\n/**\n * @deprecated use {@link iterator} instead\n */\nexport const $$iterator = iterator;\n","import { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\n\nexport const subscribeToIterable = <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => {\n  const iterator = iterable[Symbol_iterator]();\n  do {\n    const item = iterator.next();\n    if (item.done) {\n      subscriber.complete();\n      break;\n    }\n    subscriber.next(item.value);\n    if (subscriber.closed) {\n      break;\n    }\n  } while (true);\n\n  // Finalize the iterator if it happens to be a Generator\n  if (typeof iterator.return === 'function') {\n    subscriber.add(() => {\n      if (iterator.return) {\n        iterator.return();\n      }\n    });\n  }\n\n  return subscriber;\n};\n","import { Subscriber } from '../Subscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport const subscribeToObservable = <T>(obj: any) => (subscriber: Subscriber<T>) => {\n  const obs = obj[Symbol_observable]();\n  if (typeof obs.subscribe !== 'function') {\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  } else {\n    return obs.subscribe(subscriber);\n  }\n};\n","import { Observable } from '../Observable';\nimport { ObservableInput } from '../types';\nimport { subscribeToArray } from './subscribeToArray';\nimport { subscribeToPromise } from './subscribeToPromise';\nimport { subscribeToIterable } from './subscribeToIterable';\nimport { subscribeToObservable } from './subscribeToObservable';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { Subscriber } from '../Subscriber';\n\nexport const subscribeTo = <T>(result: ObservableInput<T>) => {\n  if (result instanceof Observable) {\n    return (subscriber: Subscriber<T>) => {\n        if (result._isScalar) {\n        subscriber.next((result as any).value);\n        subscriber.complete();\n        return undefined;\n      } else {\n        return result.subscribe(subscriber);\n      }\n    };\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result as Promise<any>);\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    return subscribeToIterable(result as any);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    return subscribeToObservable(result as any);\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n","import { Injectable } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\n\n/** Enumerated actions for a popover to perform. */\nexport enum NotificationAction {\n  /** Popover should open. */\n  OPEN,\n  /** Popover should close. */\n  CLOSE,\n  /** Popover should toggle open or closed. */\n  TOGGLE,\n  /** Popover has new target positions. */\n  REPOSITION,\n  /** Popover needs new configuration. */\n  UPDATE_CONFIG,\n}\n\n/** Event object for dispatching to anchor. */\nexport class PopoverNotification {\n  constructor(\n    /** Action to perform. */\n    public action: NotificationAction,\n    /** Optional payload. */\n    public value?: any\n  ) { }\n}\n\n@Injectable()\nexport class PopoverNotificationService {\n\n  private store = new Subject<PopoverNotification>();\n\n  /** Dispatch a notification to all subscribers. */\n  dispatch(notification: PopoverNotification) {\n    this.store.next(notification);\n  }\n\n  /** Stream of notification events. */\n  events(): Observable<PopoverNotification> {\n    return this.store.asObservable();\n  }\n\n  /** Complete event stream. */\n  dispose(): void {\n    this.store.complete();\n  }\n\n}\n","import {\n  Component,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  ViewChild,\n  ViewEncapsulation,\n  TemplateRef,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n} from '@angular/core';\nimport { AnimationEvent } from '@angular/animations';\nimport { DOCUMENT } from '@angular/common';\nimport { FocusTrap, FocusTrapFactory } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Subject } from 'rxjs';\n\nimport { transformPopover } from './popover.animations';\nimport {\n  NotificationAction,\n  PopoverNotification,\n  PopoverNotificationService,\n} from './notification.service';\nimport {\n  getUnanchoredPopoverError,\n  getInvalidHorizontalAlignError,\n  getInvalidVerticalAlignError,\n  getInvalidScrollStrategyError,\n} from './popover.errors';\n\nexport type SatPopoverScrollStrategy = 'noop' | 'block' | 'reposition' | 'close';\nexport type SatPopoverHorizontalAlign = 'before' | 'start' | 'center' | 'end' | 'after';\nexport type SatPopoverVerticalAlign = 'above'  | 'start' | 'center' | 'end' | 'below';\n\nexport const VALID_SCROLL: SatPopoverScrollStrategy[] = ['noop', 'block', 'reposition', 'close'];\nexport const VALID_HORIZ_ALIGN: SatPopoverHorizontalAlign[] =\n    ['before', 'start', 'center', 'end', 'after'];\nexport const VALID_VERT_ALIGN: SatPopoverVerticalAlign[] =\n    ['above', 'start', 'center', 'end', 'below'];\n\n// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.\nconst DEFAULT_TRANSITION  = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';\n\n@Component({\n  selector: 'sat-popover',\n  encapsulation: ViewEncapsulation.None,\n  animations: [transformPopover],\n  styleUrls: ['./popover.component.scss'],\n  templateUrl: './popover.component.html',\n})\nexport class SatPopover implements OnInit, OnDestroy {\n\n  /** Alignment of the popover on the horizontal axis. */\n  @Input()\n  get horizontalAlign() { return this._horizontalAlign; }\n  set horizontalAlign(val: SatPopoverHorizontalAlign) {\n    this._validateHorizontalAlign(val);\n    if (this._horizontalAlign !== val) {\n      this._horizontalAlign = val;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _horizontalAlign: SatPopoverHorizontalAlign = 'center';\n\n  /** Alignment of the popover on the x axis. Alias for `horizontalAlign`. */\n  @Input()\n  get xAlign() { return this.horizontalAlign; }\n  set xAlign(val: SatPopoverHorizontalAlign) { this.horizontalAlign = val; }\n\n  /** Alignment of the popover on the vertical axis. */\n  @Input()\n  get verticalAlign() { return this._verticalAlign; }\n  set verticalAlign(val: SatPopoverVerticalAlign) {\n    this._validateVerticalAlign(val);\n    if (this._verticalAlign !== val) {\n      this._verticalAlign = val;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _verticalAlign: SatPopoverVerticalAlign = 'center';\n\n  /** Alignment of the popover on the y axis. Alias for `verticalAlign`. */\n  @Input()\n  get yAlign() { return this.verticalAlign; }\n  set yAlign(val: SatPopoverVerticalAlign) { this.verticalAlign = val; }\n\n  /** Whether the popover always opens with the specified alignment. */\n  @Input()\n  get forceAlignment() { return this._forceAlignment; }\n  set forceAlignment(val: boolean) {\n    const coercedVal = coerceBooleanProperty(val);\n    if (this._forceAlignment !== coercedVal) {\n      this._forceAlignment = coercedVal;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _forceAlignment = false;\n\n  /**\n   * Whether the popover's alignment is locked after opening. This prevents the popover\n   * from changing its alignement when scrolling or changing the size of the viewport.\n   */\n  @Input()\n  get lockAlignment() { return this._lockAlignment; }\n  set lockAlignment(val: boolean) {\n    const coercedVal = coerceBooleanProperty(val);\n    if (this._lockAlignment !== coercedVal) {\n      this._lockAlignment = coerceBooleanProperty(val);\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));\n    }\n  }\n  private _lockAlignment = false;\n\n  /** Whether the first focusable element should be focused on open. */\n  @Input()\n  get autoFocus() { return this._autoFocus; }\n  set autoFocus(val: boolean) {\n    this._autoFocus = coerceBooleanProperty(val);\n  }\n  private _autoFocus = true;\n\n  /** How the popover should handle scrolling. */\n  @Input()\n  get scrollStrategy() { return this._scrollStrategy; }\n  set scrollStrategy(val: SatPopoverScrollStrategy) {\n    this._validateScrollStrategy(val);\n    if (this._scrollStrategy !== val) {\n      this._scrollStrategy = val;\n      this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));\n    }\n  }\n  private _scrollStrategy: SatPopoverScrollStrategy = 'reposition';\n\n  /** Whether the popover should have a backdrop (includes closing on click). */\n  @Input()\n  get hasBackdrop() { return this._hasBackdrop; }\n  set hasBackdrop(val: boolean) {\n    this._hasBackdrop = coerceBooleanProperty(val);\n  }\n  private _hasBackdrop = false;\n\n  /** Whether the popover should close when the user clicks the backdrop or presses ESC. */\n  @Input()\n  get interactiveClose() { return this._interactiveClose; }\n  set interactiveClose(val: boolean) {\n    this._interactiveClose = coerceBooleanProperty(val);\n  }\n  private _interactiveClose = true;\n\n  /** Custom transition to use while opening. */\n  @Input()\n  get openTransition() { return this._openTransition; }\n  set openTransition(val: string) {\n    if (val) {\n      this._openTransition = val;\n    }\n  }\n  private _openTransition = DEFAULT_TRANSITION;\n\n  /** Custom transition to use while closing. */\n  @Input()\n  get closeTransition() { return this._closeTransition; }\n  set closeTransition(val: string) {\n    if (val) {\n      this._closeTransition = val;\n    }\n  }\n  private _closeTransition = DEFAULT_TRANSITION;\n\n  /** Optional backdrop class. */\n  @Input() backdropClass = '';\n\n  /** Emits when the popover is opened. */\n  @Output() opened = new EventEmitter<void>();\n\n  /** Emits when the popover is closed. */\n  @Output() closed = new EventEmitter<any>();\n\n  /** Emits when the popover has finished opening. */\n  @Output() afterOpen = new EventEmitter<void>();\n\n  /** Emits when the popover has finished closing. */\n  @Output() afterClose = new EventEmitter<void>();\n\n  /** Emits when the backdrop is clicked. */\n  @Output() backdropClicked = new EventEmitter<void>();\n\n  /** Emits when a keydown event is targeted to this popover's overlay. */\n  @Output() overlayKeydown = new EventEmitter<KeyboardEvent>();\n\n  /** Reference to template so it can be placed within a portal. */\n  @ViewChild(TemplateRef) _templateRef: TemplateRef<any>;\n\n  /** Classes to be added to the popover for setting the correct transform origin. */\n  _classList: any = {};\n\n  /** Whether the popover is presently open. */\n  _open = false;\n\n  /** Instance of notification service. Will be undefined until attached to an anchor. */\n  _notifications: PopoverNotificationService;\n\n  /** Reference to the element to build a focus trap around. */\n  @ViewChild('focusTrapElement')\n  private _focusTrapElement: ElementRef;\n\n  /** Reference to the element that was focused before opening. */\n  private _previouslyFocusedElement: HTMLElement;\n\n  /** Reference to a focus trap around the popover. */\n  private _focusTrap: FocusTrap;\n\n  constructor(\n    private _focusTrapFactory: FocusTrapFactory,\n    @Optional() @Inject(DOCUMENT) private _document: any\n  ) { }\n\n  ngOnInit() {\n    this._setAlignmentClasses();\n  }\n\n  ngOnDestroy() {\n    if (this._notifications) {\n      this._notifications.dispose();\n    }\n  }\n\n  /** Open this popover. */\n  open(): void {\n    const notification = new PopoverNotification(NotificationAction.OPEN);\n    this._dispatchActionNotification(notification);\n  }\n\n  /** Close this popover. */\n  close(value?: any): void {\n    const notification = new PopoverNotification(NotificationAction.CLOSE, value);\n    this._dispatchActionNotification(notification);\n  }\n\n  /** Toggle this popover open or closed. */\n  toggle(): void {\n    const notification = new PopoverNotification(NotificationAction.TOGGLE);\n    this._dispatchActionNotification(notification);\n  }\n\n  /** Gets whether the popover is presently open. */\n  isOpen(): boolean {\n    return this._open;\n  }\n\n  /** Gets an animation config with customized (or default) transition values. */\n  _getAnimation(): { value: any, params: any } {\n    return {\n      value: 'visible',\n      params: { openTransition: this.openTransition, closeTransition: this.closeTransition }\n    };\n  }\n\n  /** Callback for when the popover is finished animating in or out. */\n  _onAnimationDone(event: AnimationEvent) {\n    if (event.toState === 'visible') {\n      this._trapFocus();\n      this.afterOpen.emit();\n    } else if (event.toState === 'void') {\n      this._restoreFocus();\n      this.afterClose.emit();\n    }\n  }\n\n  /** Apply alignment classes based on alignment inputs. */\n  _setAlignmentClasses(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {\n    this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';\n    this._classList['sat-popover-after']  = horizAlign === 'after' || horizAlign === 'start';\n\n    this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';\n    this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';\n\n    this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';\n  }\n\n  /** Move the focus inside the focus trap and remember where to return later. */\n  private _trapFocus(): void {\n    this._savePreviouslyFocusedElement();\n\n    // There won't be a focus trap element if the close animation starts before open finishes\n    if (!this._focusTrapElement) {\n      return;\n    }\n\n    if (!this._focusTrap && this._focusTrapElement) {\n      this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);\n    }\n\n    if (this.autoFocus) {\n      this._focusTrap.focusInitialElementWhenReady();\n    }\n  }\n\n  /** Restore focus to the element focused before the popover opened. Also destroy trap. */\n  private _restoreFocus(): void {\n    const toFocus = this._previouslyFocusedElement;\n\n    // Must check active element is focusable for IE sake\n    if (toFocus && 'focus' in toFocus) {\n      this._previouslyFocusedElement.focus();\n    }\n\n    this._previouslyFocusedElement = null;\n\n    if (this._focusTrap) {\n      this._focusTrap.destroy();\n      this._focusTrap = undefined;\n    }\n  }\n\n  /** Save a reference to the element focused before the popover was opened. */\n  private _savePreviouslyFocusedElement(): void {\n    if (this._document) {\n      this._previouslyFocusedElement = this._document.activeElement as HTMLElement;\n    }\n  }\n\n  /** Dispatch a notification to the notification service, if possible. */\n  private _dispatchConfigNotification(notification: PopoverNotification) {\n    if (this._notifications) {\n      this._notifications.dispatch(notification);\n    }\n  }\n\n  /** Dispatch a notification to the notification service and throw if unable to. */\n  private _dispatchActionNotification(notification: PopoverNotification) {\n    if (!this._notifications) {\n      throw getUnanchoredPopoverError();\n    }\n\n    this._notifications.dispatch(notification);\n  }\n\n  /** Throws an error if the alignment is not a valid horizontalAlign. */\n  private _validateHorizontalAlign(pos: SatPopoverHorizontalAlign): void {\n    if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {\n      throw getInvalidHorizontalAlignError(pos);\n    }\n  }\n\n  /** Throws an error if the alignment is not a valid verticalAlign. */\n  private _validateVerticalAlign(pos: SatPopoverVerticalAlign): void {\n    if (VALID_VERT_ALIGN.indexOf(pos) === -1) {\n      throw getInvalidVerticalAlignError(pos);\n    }\n  }\n\n  /** Throws an error if the scroll strategy is not a valid strategy. */\n  private _validateScrollStrategy(strategy: SatPopoverScrollStrategy): void {\n    if (VALID_SCROLL.indexOf(strategy) === -1) {\n      throw getInvalidScrollStrategyError(strategy);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction, MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, PartialObserver, TeardownLogic } from '../types';\nimport { noop } from '../util/noop';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function tap<T>(next?: (x: T) => void, error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>;\nexport function tap<T>(observer: PartialObserver<T>): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @name tap\n */\nexport function tap<T>(nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n                       error?: (e: any) => void,\n                       complete?: () => void): MonoTypeOperatorFunction<T> {\n  return function tapOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new DoOperator(nextOrObserver, error, complete));\n  };\n}\n\nclass DoOperator<T> implements Operator<T, T> {\n  constructor(private nextOrObserver?: PartialObserver<T> | ((x: T) => void),\n              private error?: (e: any) => void,\n              private complete?: () => void) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nclass TapSubscriber<T> extends Subscriber<T> {\n  private _context: any;\n\n  private _tapNext: ((value: T) => void) = noop;\n\n  private _tapError: ((err: any) => void) = noop;\n\n  private _tapComplete: (() => void) = noop;\n\n  constructor(destination: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n      super(destination);\n      this._tapError = error || noop;\n      this._tapComplete = complete || noop;\n      if (isFunction(observerOrNext)) {\n        this._context = this;\n        this._tapNext = observerOrNext;\n      } else if (observerOrNext) {\n        this._context = observerOrNext;\n        this._tapNext = observerOrNext.next || noop;\n        this._tapError = observerOrNext.error || noop;\n        this._tapComplete = observerOrNext.complete || noop;\n      }\n    }\n\n  _next(value: T) {\n    try {\n      this._tapNext.call(this._context, value);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(value);\n  }\n\n  _error(err: any) {\n    try {\n      this._tapError.call(this._context, err);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.error(err);\n  }\n\n  _complete() {\n    try {\n      this._tapComplete.call(this._context, );\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    return this.destination.complete();\n  }\n}\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\n\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * <img src=\"./img/takeUntil.png\" width=\"100%\">\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * @example <caption>Tick every second until the first click happens</caption>\n * var interval = Rx.Observable.interval(1000);\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = interval.takeUntil(clicks);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return {Observable<T>} An Observable that emits the values from the source\n * Observable until such time as `notifier` emits its first value.\n * @method takeUntil\n * @owner Observable\n */\nexport function takeUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new TakeUntilOperator(notifier));\n}\n\nclass TakeUntilOperator<T> implements Operator<T, T> {\n  constructor(private notifier: Observable<any>) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);\n    const notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);\n    if (notifierSubscription && !notifierSubscription.closed) {\n      takeUntilSubscriber.add(notifierSubscription);\n      return source.subscribe(takeUntilSubscriber);\n    }\n    return takeUntilSubscriber;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass TakeUntilSubscriber<T, R> extends OuterSubscriber<T, R> {\n\n  constructor(destination: Subscriber<any>, ) {\n    super(destination);\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.complete();\n  }\n\n  notifyComplete(): void {\n    // noop\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  OnInit,\n  OnDestroy,\n  Output,\n  ViewContainerRef\n} from '@angular/core';\nimport { Subject, merge } from 'rxjs';\nimport { tap, takeUntil } from 'rxjs/operators';\n\nimport { SatPopover } from './popover.component';\nimport { getInvalidPopoverError } from './popover.errors';\nimport { PopoverAnchoringService } from './popover-anchoring.service';\n\n@Directive({\n  selector: '[satPopoverAnchorFor]',\n  exportAs: 'satPopoverAnchor',\n  providers: [PopoverAnchoringService],\n})\nexport class SatPopoverAnchor implements OnInit, OnDestroy {\n\n  /** Reference to the popover instance. */\n  @Input('satPopoverAnchorFor')\n  get attachedPopover() { return this._attachedPopover; }\n  set attachedPopover(value: SatPopover) {\n    this._validateAttachedPopover(value);\n    this._attachedPopover = value;\n    // Anchor the popover to the element ref\n    this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);\n  }\n  private _attachedPopover: SatPopover;\n\n  /** Emits when the popover is opened. */\n  @Output() popoverOpened = new EventEmitter<void>();\n\n  /** Emits when the popover is closed. */\n  @Output() popoverClosed = new EventEmitter<any>();\n\n  /** Gets whether the popover is presently open. */\n  isPopoverOpen(): boolean {\n    return this._anchoring.isPopoverOpen();\n  }\n\n  /** Emits when the directive is destroyed. */\n  private _onDestroy = new Subject<void>();\n\n  constructor(\n    private _elementRef: ElementRef,\n    private _viewContainerRef: ViewContainerRef,\n    public _anchoring: PopoverAnchoringService,\n  ) { }\n\n  ngOnInit() {\n    // Re-emit open and close events\n    const opened$ = this._anchoring.popoverOpened\n      .pipe(tap(() => this.popoverOpened.emit()));\n    const closed$ = this._anchoring.popoverClosed\n      .pipe(tap(value => this.popoverClosed.emit(value)));\n    merge(opened$, closed$).pipe(takeUntil(this._onDestroy)).subscribe();\n  }\n\n  ngOnDestroy() {\n    this._onDestroy.next();\n    this._onDestroy.complete();\n  }\n\n  /** Toggles the popover between the open and closed states. */\n  togglePopover(): void {\n    this._anchoring.togglePopover();\n  }\n\n  /** Opens the popover. */\n  openPopover(): void {\n    this._anchoring.openPopover();\n  }\n\n  /** Closes the popover. */\n  closePopover(value?: any): void {\n    this._anchoring.closePopover(value);\n  }\n\n  /** Throws an error if the popover instance is not provided. */\n  private _validateAttachedPopover(popover: SatPopover): void {\n    if (!popover || !(popover instanceof SatPopover)) {\n      throw getInvalidPopoverError();\n    }\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport { A11yModule } from '@angular/cdk/a11y';\nimport { BidiModule } from '@angular/cdk/bidi';\n\nimport { SatPopover } from './popover.component';\nimport { SatPopoverAnchor } from './popover-anchor.directive';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    OverlayModule,\n    A11yModule,\n    BidiModule,\n  ],\n  declarations: [\n    SatPopover,\n    SatPopoverAnchor,\n  ],\n  exports: [\n    SatPopover,\n    SatPopoverAnchor,\n    BidiModule,\n  ]\n})\nexport class SatPopoverModule { }\n"]}