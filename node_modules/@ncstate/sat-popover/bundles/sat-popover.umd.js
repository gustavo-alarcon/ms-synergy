(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/cdk/a11y'), require('@angular/platform-browser'), require('@angular/cdk/coercion'), require('@angular/animations'), require('rxjs/Subject'), require('rxjs/observable/merge'), require('rxjs/operators/tap'), require('rxjs/operators/takeUntil'), require('@angular/cdk/keycodes'), require('@angular/cdk/portal'), require('rxjs/operators/take'), require('rxjs/operators/filter')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/common', '@angular/cdk/overlay', '@angular/cdk/a11y', '@angular/platform-browser', '@angular/cdk/coercion', '@angular/animations', 'rxjs/Subject', 'rxjs/observable/merge', 'rxjs/operators/tap', 'rxjs/operators/takeUntil', '@angular/cdk/keycodes', '@angular/cdk/portal', 'rxjs/operators/take', 'rxjs/operators/filter'], factory) :
	(factory((global.popover = {}),global.ng.core,global.ng.common,global.ng.cdk.overlay,global.ng.cdk.a11y,global.ng.platformBrowser,global.ng.cdk.coercion,global.ng.animations,global.Rx,global.Rx.Observable,global.Rx.operators,global.Rx.operators,global.ng.cdk.keycodes,global.ng.cdk.portal,global.Rx.operators,global.Rx.operators));
}(this, (function (exports,core,common,overlay,a11y,platformBrowser,coercion,animations,Subject,merge,tap,takeUntil,keycodes,portal,take,filter) { 'use strict';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Injection token used to inject the document into Directionality.
 * This is used so that the value can be faked in tests.
 *
 * We can't use the real document in tests because changing the real `dir` causes geometry-based
 * tests in Safari to fail.
 *
 * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests
 * themselves use things like `querySelector` in test code.
 */
var DIR_DOCUMENT = new core.InjectionToken('cdk-dir-doc');
/**
 * The directionality (LTR / RTL) context for the application (or a subtree of it).
 * Exposes the current direction and a stream of direction changes.
 */
var Directionality = /** @class */ (function () {
    function Directionality(_document) {
        /**
         * The current 'ltr' or 'rtl' value.
         */
        this.value = 'ltr';
        /**
         * Stream that emits whenever the 'ltr' / 'rtl' state changes.
         */
        this.change = new core.EventEmitter();
        if (_document) {
            // TODO: handle 'auto' value -
            // We still need to account for dir="auto".
            // It looks like HTMLElemenet.dir is also "auto" when that's set to the attribute,
            // but getComputedStyle return either "ltr" or "rtl". avoiding getComputedStyle for now
            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;
            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;
            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));
        }
    }
    Directionality.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    Directionality.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [DIR_DOCUMENT,] },] },
    ]; };
    return Directionality;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Directive to listen for changes of direction of part of the DOM.
 *
 * Provides itself as Directionality such that descendant directives only need to ever inject
 * Directionality to get the closest direction.
 */
var Dir = /** @class */ (function () {
    function Dir() {
        this._dir = 'ltr';
        /**
         * Whether the `value` has been set to its initial value.
         */
        this._isInitialized = false;
        /**
         * Event emitted when the direction changes.
         */
        this.change = new core.EventEmitter();
    }
    Object.defineProperty(Dir.prototype, "dir", {
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () { return this._dir; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            var /** @type {?} */ old = this._dir;
            this._dir = v;
            if (old !== this._dir && this._isInitialized) {
                this.change.emit(this._dir);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dir.prototype, "value", {
        /** Current layout direction of the element. */
        get: /**
         * Current layout direction of the element.
         * @return {?}
         */
        function () { return this.dir; },
        enumerable: true,
        configurable: true
    });
    /** Initialize once default value has been set. */
    /**
     * Initialize once default value has been set.
     * @return {?}
     */
    Dir.prototype.ngAfterContentInit = /**
     * Initialize once default value has been set.
     * @return {?}
     */
    function () {
        this._isInitialized = true;
    };
    Dir.decorators = [
        { type: core.Directive, args: [{
                    selector: '[dir]',
                    providers: [{ provide: Directionality, useExisting: Dir }],
                    host: { '[dir]': 'dir' },
                    exportAs: 'dir',
                },] },
    ];
    /** @nocollapse */
    Dir.ctorParameters = function () { return []; };
    Dir.propDecorators = {
        "change": [{ type: core.Output, args: ['dirChange',] },],
        "dir": [{ type: core.Input, args: ['dir',] },],
    };
    return Dir;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var BidiModule = /** @class */ (function () {
    function BidiModule() {
    }
    BidiModule.decorators = [
        { type: core.NgModule, args: [{
                    exports: [Dir],
                    declarations: [Dir],
                    providers: [
                        { provide: DIR_DOCUMENT, useExisting: common.DOCUMENT },
                        Directionality,
                    ]
                },] },
    ];
    /** @nocollapse */
    BidiModule.ctorParameters = function () { return []; };
    return BidiModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var transformPopover = animations.trigger('transformPopover', [
    animations.transition(':enter', [
        animations.style({ opacity: 0, transform: 'scale(0.3)' }),
        animations.animate('{{openTransition}}', animations.style({ opacity: 1, transform: 'scale(1)' }))
    ]),
    animations.transition(':leave', [
        animations.animate('{{closeTransition}}', animations.style({ opacity: 0, transform: 'scale(0.5)' }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
var NotificationAction = {
    /** Popover should open. */
    OPEN: 0,
    /** Popover should close. */
    CLOSE: 1,
    /** Popover should toggle open or closed. */
    TOGGLE: 2,
    /** Popover has new target positions. */
    REPOSITION: 3,
    /** Popover needs new configuration. */
    UPDATE_CONFIG: 4,
};
NotificationAction[NotificationAction.OPEN] = "OPEN";
NotificationAction[NotificationAction.CLOSE] = "CLOSE";
NotificationAction[NotificationAction.TOGGLE] = "TOGGLE";
NotificationAction[NotificationAction.REPOSITION] = "REPOSITION";
NotificationAction[NotificationAction.UPDATE_CONFIG] = "UPDATE_CONFIG";
/**
 * Event object for dispatching to anchor.
 */
var PopoverNotification = (function () {
    function PopoverNotification(action, value) {
        this.action = action;
        this.value = value;
    }
    return PopoverNotification;
}());
var PopoverNotificationService = (function () {
    function PopoverNotificationService() {
        this.store = new Subject.Subject();
    }
    /** Dispatch a notification to all subscribers. */
    /**
     * Dispatch a notification to all subscribers.
     * @param {?} notification
     * @return {?}
     */
    PopoverNotificationService.prototype.dispatch = /**
     * Dispatch a notification to all subscribers.
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        this.store.next(notification);
    };
    /** Stream of notification events. */
    /**
     * Stream of notification events.
     * @return {?}
     */
    PopoverNotificationService.prototype.events = /**
     * Stream of notification events.
     * @return {?}
     */
    function () {
        return this.store.asObservable();
    };
    /** Complete event stream. */
    /**
     * Complete event stream.
     * @return {?}
     */
    PopoverNotificationService.prototype.dispose = /**
     * Complete event stream.
     * @return {?}
     */
    function () {
        this.store.complete();
    };
    PopoverNotificationService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    PopoverNotificationService.ctorParameters = function () { return []; };
    return PopoverNotificationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function getInvalidPopoverError() {
    return Error('SatPopoverAnchor must be provided an SatPopover component instance.');
}
/**
 * @return {?}
 */
function getUnanchoredPopoverError() {
    return Error('SatPopover is not anchored to any SatPopoverAnchor.');
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidHorizontalAlignError(alignment) {
    return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidVerticalAlignError(alignment) {
    return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));
}
/**
 * @param {?} strategy
 * @return {?}
 */
function getInvalidScrollStrategyError(strategy) {
    return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));
}
/**
 * @param {?} apiName
 * @param {?} invalid
 * @param {?} valid
 * @return {?}
 */
function generateGenericError(apiName, invalid, valid) {
    return "Invalid " + apiName + ": '" + invalid + "'. Valid options are " +
        (valid.map(function (v) { return "'" + v + "'"; }).join(', ') + ".");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var VALID_SCROLL = ['noop', 'block', 'reposition', 'close'];
var VALID_HORIZ_ALIGN = ['before', 'start', 'center', 'end', 'after'];
var VALID_VERT_ALIGN = ['above', 'start', 'center', 'end', 'below'];
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
var DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
var SatPopover = (function () {
    function SatPopover(_focusTrapFactory, _document) {
        this._focusTrapFactory = _focusTrapFactory;
        this._document = _document;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'center';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = false;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Optional backdrop class.
         */
        this.backdropClass = '';
        /**
         * Emits when the popover is opened.
         */
        this.opened = new core.EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new core.EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new core.EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new core.EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new core.EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new core.EventEmitter();
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
    }
    Object.defineProperty(SatPopover.prototype, "horizontalAlign", {
        get: /**
         * Alignment of the popover on the horizontal axis.
         * @return {?}
         */
        function () { return this._horizontalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateHorizontalAlign(val);
            if (this._horizontalAlign !== val) {
                this._horizontalAlign = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "xAlign", {
        get: /**
         * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
         * @return {?}
         */
        function () { return this.horizontalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { this.horizontalAlign = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "verticalAlign", {
        get: /**
         * Alignment of the popover on the vertical axis.
         * @return {?}
         */
        function () { return this._verticalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateVerticalAlign(val);
            if (this._verticalAlign !== val) {
                this._verticalAlign = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "yAlign", {
        get: /**
         * Alignment of the popover on the y axis. Alias for `verticalAlign`.
         * @return {?}
         */
        function () { return this.verticalAlign; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { this.verticalAlign = val; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "forceAlignment", {
        get: /**
         * Whether the popover always opens with the specified alignment.
         * @return {?}
         */
        function () { return this._forceAlignment; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var /** @type {?} */ coercedVal = coercion.coerceBooleanProperty(val);
            if (this._forceAlignment !== coercedVal) {
                this._forceAlignment = coercedVal;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "lockAlignment", {
        get: /**
         * Whether the popover's alignment is locked after opening. This prevents the popover
         * from changing its alignement when scrolling or changing the size of the viewport.
         * @return {?}
         */
        function () { return this._lockAlignment; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var /** @type {?} */ coercedVal = coercion.coerceBooleanProperty(val);
            if (this._lockAlignment !== coercedVal) {
                this._lockAlignment = coercion.coerceBooleanProperty(val);
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "autoFocus", {
        get: /**
         * Whether the first focusable element should be focused on open.
         * @return {?}
         */
        function () { return this._autoFocus; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._autoFocus = coercion.coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "scrollStrategy", {
        get: /**
         * How the popover should handle scrolling.
         * @return {?}
         */
        function () { return this._scrollStrategy; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._validateScrollStrategy(val);
            if (this._scrollStrategy !== val) {
                this._scrollStrategy = val;
                this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "hasBackdrop", {
        get: /**
         * Whether the popover should have a backdrop (includes closing on click).
         * @return {?}
         */
        function () { return this._hasBackdrop; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._hasBackdrop = coercion.coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "interactiveClose", {
        get: /**
         * Whether the popover should close when the user clicks the backdrop or presses ESC.
         * @return {?}
         */
        function () { return this._interactiveClose; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._interactiveClose = coercion.coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "openTransition", {
        get: /**
         * Custom transition to use while opening.
         * @return {?}
         */
        function () { return this._openTransition; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._openTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SatPopover.prototype, "closeTransition", {
        get: /**
         * Custom transition to use while closing.
         * @return {?}
         */
        function () { return this._closeTransition; },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._closeTransition = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SatPopover.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._setAlignmentClasses();
    };
    /**
     * @return {?}
     */
    SatPopover.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._notifications) {
            this._notifications.dispose();
        }
    };
    /** Open this popover. */
    /**
     * Open this popover.
     * @return {?}
     */
    SatPopover.prototype.open = /**
     * Open this popover.
     * @return {?}
     */
    function () {
        var /** @type {?} */ notification = new PopoverNotification(NotificationAction.OPEN);
        this._dispatchActionNotification(notification);
    };
    /** Close this popover. */
    /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopover.prototype.close = /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        var /** @type {?} */ notification = new PopoverNotification(NotificationAction.CLOSE, value);
        this._dispatchActionNotification(notification);
    };
    /** Toggle this popover open or closed. */
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    SatPopover.prototype.toggle = /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    function () {
        var /** @type {?} */ notification = new PopoverNotification(NotificationAction.TOGGLE);
        this._dispatchActionNotification(notification);
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopover.prototype.isOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._open;
    };
    /** Gets an animation config with customized (or default) transition values. */
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    SatPopover.prototype._getAnimation = /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    function () {
        return {
            value: 'visible',
            params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
        };
    };
    /** Callback for when the popover is finished animating in or out. */
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    SatPopover.prototype._onAnimationDone = /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocus();
            this.afterClose.emit();
        }
    };
    /** Apply alignment classes based on alignment inputs. */
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    SatPopover.prototype._setAlignmentClasses = /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    function (horizAlign, vertAlign) {
        if (horizAlign === void 0) { horizAlign = this.horizontalAlign; }
        if (vertAlign === void 0) { vertAlign = this.verticalAlign; }
        this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
    };
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @return {?}
     */
    SatPopover.prototype._trapFocus = /**
     * Move the focus inside the focus trap and remember where to return later.
     * @return {?}
     */
    function () {
        this._savePreviouslyFocusedElement();
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    };
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    SatPopover.prototype._restoreFocus = /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    function () {
        var /** @type {?} */ toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    };
    /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    SatPopover.prototype._savePreviouslyFocusedElement = /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    function () {
        if (this._document) {
            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);
        }
    };
    /**
     * Dispatch a notification to the notification service, if possible.
     * @param {?} notification
     * @return {?}
     */
    SatPopover.prototype._dispatchConfigNotification = /**
     * Dispatch a notification to the notification service, if possible.
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        if (this._notifications) {
            this._notifications.dispatch(notification);
        }
    };
    /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @param {?} notification
     * @return {?}
     */
    SatPopover.prototype._dispatchActionNotification = /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @param {?} notification
     * @return {?}
     */
    function (notification) {
        if (!this._notifications) {
            throw getUnanchoredPopoverError();
        }
        this._notifications.dispatch(notification);
    };
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @param {?} pos
     * @return {?}
     */
    SatPopover.prototype._validateHorizontalAlign = /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    };
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @param {?} pos
     * @return {?}
     */
    SatPopover.prototype._validateVerticalAlign = /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @param {?} pos
     * @return {?}
     */
    function (pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    };
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @param {?} strategy
     * @return {?}
     */
    SatPopover.prototype._validateScrollStrategy = /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    };
    SatPopover.decorators = [
        { type: core.Component, args: [{
                    selector: 'sat-popover',
                    encapsulation: core.ViewEncapsulation.None,
                    animations: [transformPopover],
                    styles: ["/** * Applies styles for users in high contrast mode. Note that this only applies * to Microsoft browsers. Chrome can be included by checking for the `html[hc]` * attribute, however Chrome handles high contrast differently. */ /* Theme for the ripple elements.*/ /** The mixins below are shared between mat-menu and mat-select */ /** * This mixin adds the correct panel transform styles based * on the direction that the menu panel opens. */ /* stylelint-disable material/no-prefixes */ /* stylelint-enable */ /** * This mixin contains shared option styles between the select and * autocomplete components. */ .cdk-overlay-container, .cdk-global-overlay-wrapper { pointer-events: none; top: 0; left: 0; height: 100%; width: 100%; } .cdk-overlay-container { position: fixed; z-index: 1000; } .cdk-global-overlay-wrapper { display: flex; position: absolute; z-index: 1000; } .cdk-overlay-pane { position: absolute; pointer-events: auto; box-sizing: border-box; z-index: 1000; } .cdk-overlay-backdrop { position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1000; pointer-events: auto; -webkit-tap-highlight-color: transparent; transition: opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1); opacity: 0; } .cdk-overlay-backdrop.cdk-overlay-backdrop-showing { opacity: 0.48; } .cdk-overlay-dark-backdrop { background: rgba(0, 0, 0, 0.6); } .cdk-overlay-transparent-backdrop { background: none; } .cdk-global-scrollblock { position: fixed; width: 100%; overflow-y: scroll; } .sat-popover-container.sat-popover-before.sat-popover-above { transform-origin: right bottom; } [dir='rtl'] .sat-popover-container.sat-popover-before.sat-popover-above { transform-origin: left bottom; } .sat-popover-container.sat-popover-before.sat-popover-center { transform-origin: right center; } [dir='rtl'] .sat-popover-container.sat-popover-before.sat-popover-center { transform-origin: left center; } .sat-popover-container.sat-popover-before.sat-popover-below { transform-origin: right top; } [dir='rtl'] .sat-popover-container.sat-popover-before.sat-popover-below { transform-origin: left top; } .sat-popover-container.sat-popover-center.sat-popover-above { transform-origin: center bottom; } .sat-popover-container.sat-popover-center.sat-popover-below { transform-origin: center top; } .sat-popover-container.sat-popover-after.sat-popover-above { transform-origin: left bottom; } [dir='rtl'] .sat-popover-container.sat-popover-after.sat-popover-above { transform-origin: right bottom; } .sat-popover-container.sat-popover-after.sat-popover-center { transform-origin: left center; } [dir='rtl'] .sat-popover-container.sat-popover-after.sat-popover-center { transform-origin: right center; } .sat-popover-container.sat-popover-after.sat-popover-below { transform-origin: left top; } [dir='rtl'] .sat-popover-container.sat-popover-after.sat-popover-below { transform-origin: right top; } "],
                    template: "<ng-template> <div class=\"sat-popover-container\" #focusTrapElement [ngClass]=\"_classList\" [@transformPopover]=\"_getAnimation()\" (@transformPopover.done)=\"_onAnimationDone($event)\"> <ng-content></ng-content> </div> </ng-template> ",
                },] },
    ];
    /** @nocollapse */
    SatPopover.ctorParameters = function () { return [
        { type: a11y.FocusTrapFactory, },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [platformBrowser.DOCUMENT,] },] },
    ]; };
    SatPopover.propDecorators = {
        "horizontalAlign": [{ type: core.Input },],
        "xAlign": [{ type: core.Input },],
        "verticalAlign": [{ type: core.Input },],
        "yAlign": [{ type: core.Input },],
        "forceAlignment": [{ type: core.Input },],
        "lockAlignment": [{ type: core.Input },],
        "autoFocus": [{ type: core.Input },],
        "scrollStrategy": [{ type: core.Input },],
        "hasBackdrop": [{ type: core.Input },],
        "interactiveClose": [{ type: core.Input },],
        "openTransition": [{ type: core.Input },],
        "closeTransition": [{ type: core.Input },],
        "backdropClass": [{ type: core.Input },],
        "opened": [{ type: core.Output },],
        "closed": [{ type: core.Output },],
        "afterOpen": [{ type: core.Output },],
        "afterClose": [{ type: core.Output },],
        "backdropClicked": [{ type: core.Output },],
        "overlayKeydown": [{ type: core.Output },],
        "_templateRef": [{ type: core.ViewChild, args: [core.TemplateRef,] },],
        "_focusTrapElement": [{ type: core.ViewChild, args: ['focusTrapElement',] },],
    };
    return SatPopover;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PopoverAnchoringService = (function () {
    function PopoverAnchoringService(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject.Subject();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject.Subject();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject.Subject();
    }
    /**
     * @return {?}
     */
    PopoverAnchoringService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    };
    /** Anchor a popover instance to a view and connection element. */
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    PopoverAnchoringService.prototype.anchor = /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    function (popover, viewContainerRef, anchor) {
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor;
        // Provide notification service as a communication channel between popover and anchor.
        // Then subscribe to notifications to take appropriate actions.
        this._popover._notifications = this._notifications = new PopoverNotificationService();
        this._subscribeToNotifications();
    };
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    PopoverAnchoringService.prototype.isPopoverOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._popoverOpen;
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    PopoverAnchoringService.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @return {?}
     */
    PopoverAnchoringService.prototype.openPopover = /**
     * Opens the popover.
     * @return {?}
     */
    function () {
        if (!this._popoverOpen) {
            this.createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    PopoverAnchoringService.prototype.closePopover = /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    };
    /** Create an overlay to be attached to the portal. */
    /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    PopoverAnchoringService.prototype.createOverlay = /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    function () {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new portal.TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            var /** @type {?} */ popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            var /** @type {?} */ overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges(/** @type {?} */ (overlayConfig.positionStrategy));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    };
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    PopoverAnchoringService.prototype._destroyPopover = /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    };
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    PopoverAnchoringService.prototype._destroyPopoverOnceClosed = /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take.take(1), takeUntil.takeUntil(this._onDestroy)).subscribe(function () { return _this._destroyPopover(); });
        }
        else {
            this._destroyPopover();
        }
    };
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    PopoverAnchoringService.prototype._subscribeToNotifications = /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        this._notificationsSubscription = this._notifications.events()
            .subscribe(function (event) {
            switch (event.action) {
                case NotificationAction.OPEN:
                    _this.openPopover();
                    break;
                case NotificationAction.CLOSE:
                    _this.closePopover(event.value);
                    break;
                case NotificationAction.TOGGLE:
                    _this.togglePopover();
                    break;
                case NotificationAction.REPOSITION:
                // TODO: When the overlay's position can be dynamically changed, do not destroy
                case NotificationAction.UPDATE_CONFIG:
                    _this._destroyPopoverOnceClosed();
                    break;
            }
        });
    };
    /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    PopoverAnchoringService.prototype._subscribeToBackdrop = /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .backdropClick()
            .pipe(tap.tap(function () { return _this._popover.backdropClicked.emit(); }), filter.filter(function () { return _this._popover.interactiveClose; }), takeUntil.takeUntil(this.popoverClosed), takeUntil.takeUntil(this._onDestroy))
            .subscribe(function () { return _this.closePopover(); });
    };
    /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    PopoverAnchoringService.prototype._subscribeToEscape = /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .keydownEvents()
            .pipe(tap.tap(function (event) { return _this._popover.overlayKeydown.emit(event); }), filter.filter(function (event) { return event.keyCode === keycodes.ESCAPE; }), filter.filter(function () { return _this._popover.interactiveClose; }), takeUntil.takeUntil(this.popoverClosed), takeUntil.takeUntil(this._onDestroy))
            .subscribe(function () { return _this.closePopover(); });
    };
    /**
     * Set state back to closed when detached.
     * @return {?}
     */
    PopoverAnchoringService.prototype._subscribeToDetachments = /**
     * Set state back to closed when detached.
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayRef
            .detachments()
            .pipe(takeUntil.takeUntil(this._onDestroy))
            .subscribe(function () { return _this._saveClosedState(); });
    };
    /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    PopoverAnchoringService.prototype._saveOpenedState = /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    function () {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    };
    /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    PopoverAnchoringService.prototype._saveClosedState = /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    };
    /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    PopoverAnchoringService.prototype._getDirection = /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    function () {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    };
    /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    PopoverAnchoringService.prototype._getOverlayConfig = /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    function (config, anchor) {
        return new overlay.OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    };
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    PopoverAnchoringService.prototype._subscribeToPositionChanges = /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.onPositionChange
            .pipe(takeUntil.takeUntil(this._onDestroy))
            .subscribe(function (change) {
            // Position changes may occur outside the Angular zone
            // Position changes may occur outside the Angular zone
            _this._ngZone.run(function () {
                _this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            });
        });
    };
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    PopoverAnchoringService.prototype._getScrollStrategyInstance = /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    };
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    PopoverAnchoringService.prototype._getPositionStrategy = /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    function (horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        var _a = getHorizontalConnectionPosPair(horizontalTarget), originX = _a.originX, overlayX = _a.overlayX;
        var _b = getVerticalConnectionPosPair(verticalTarget), originY = _b.originY, overlayY = _b.overlayY;
        var /** @type {?} */ strategy = this._overlay.position()
            .connectedTo(anchor, { originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY })
            .withDirection(this._getDirection())
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            this._addFallbacks(strategy, horizontalTarget, verticalTarget);
        }
        return strategy;
    };
    /**
     * Add fallbacks to a given strategy based around target alignments.
     * @param {?} strategy
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    PopoverAnchoringService.prototype._addFallbacks = /**
     * Add fallbacks to a given strategy based around target alignments.
     * @param {?} strategy
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    function (strategy, hTarget, vTarget) {
        var _this = this;
        // Determine if the target alignments overlap the anchor
        var /** @type {?} */ horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        var /** @type {?} */ verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        var /** @type {?} */ possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        var /** @type {?} */ possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        var /** @type {?} */ fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(function (h) {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(function (v) {
                fallbacks.push({ h: h, v: v });
            });
        });
        // Remove the first fallback since it will be the target alignment that is already applied
        fallbacks.slice(1, fallbacks.length)
            .forEach(function (_a) {
            var h = _a.h, v = _a.v;
            return _this._applyFallback(strategy, h, v);
        });
    };
    /**
     * Convert a specific horizontal and vertical alignment into a fallback and apply it to
     * the strategy.
     * @param {?} strategy
     * @param {?} horizontalAlign
     * @param {?} verticalAlign
     * @return {?}
     */
    PopoverAnchoringService.prototype._applyFallback = /**
     * Convert a specific horizontal and vertical alignment into a fallback and apply it to
     * the strategy.
     * @param {?} strategy
     * @param {?} horizontalAlign
     * @param {?} verticalAlign
     * @return {?}
     */
    function (strategy, horizontalAlign, verticalAlign) {
        var _a = getHorizontalConnectionPosPair(horizontalAlign), originX = _a.originX, overlayX = _a.overlayX;
        var _b = getVerticalConnectionPosPair(verticalAlign), originY = _b.originY, overlayY = _b.overlayY;
        strategy.withFallbackPosition({ originX: originX, originY: originY }, { overlayX: overlayX, overlayY: overlayY });
    };
    PopoverAnchoringService.decorators = [
        { type: core.Injectable },
    ];
    /** @nocollapse */
    PopoverAnchoringService.ctorParameters = function () { return [
        { type: overlay.Overlay, },
        { type: core.NgZone, },
        { type: Directionality, decorators: [{ type: core.Optional },] },
    ]; };
    return PopoverAnchoringService;
}());
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    var /** @type {?} */ targetIndex = options.indexOf(target);
    // Set the first item to be the target
    var /** @type {?} */ reordered = [target];
    // Make left and right stacks where the highest priority item is last
    var /** @type {?} */ left = options.slice(0, targetIndex);
    var /** @type {?} */ right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SatPopoverAnchor = (function () {
    function SatPopoverAnchor(_elementRef, _viewContainerRef, _anchoring) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._anchoring = _anchoring;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new core.EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new core.EventEmitter();
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject.Subject();
    }
    Object.defineProperty(SatPopoverAnchor.prototype, "attachedPopover", {
        get: /**
         * Reference to the popover instance.
         * @return {?}
         */
        function () { return this._attachedPopover; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._validateAttachedPopover(value);
            this._attachedPopover = value;
            // Anchor the popover to the element ref
            this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);
        },
        enumerable: true,
        configurable: true
    });
    /** Gets whether the popover is presently open. */
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    SatPopoverAnchor.prototype.isPopoverOpen = /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    function () {
        return this._anchoring.isPopoverOpen();
    };
    /**
     * @return {?}
     */
    SatPopoverAnchor.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Re-emit open and close events
        var /** @type {?} */ opened$ = this._anchoring.popoverOpened
            .pipe(tap.tap(function () { return _this.popoverOpened.emit(); }));
        var /** @type {?} */ closed$ = this._anchoring.popoverClosed
            .pipe(tap.tap(function (value) { return _this.popoverClosed.emit(value); }));
        merge.merge(opened$, closed$).pipe(takeUntil.takeUntil(this._onDestroy)).subscribe();
    };
    /**
     * @return {?}
     */
    SatPopoverAnchor.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    SatPopoverAnchor.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        this._anchoring.togglePopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @return {?}
     */
    SatPopoverAnchor.prototype.openPopover = /**
     * Opens the popover.
     * @return {?}
     */
    function () {
        this._anchoring.openPopover();
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    SatPopoverAnchor.prototype.closePopover = /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        this._anchoring.closePopover(value);
    };
    /**
     * Throws an error if the popover instance is not provided.
     * @param {?} popover
     * @return {?}
     */
    SatPopoverAnchor.prototype._validateAttachedPopover = /**
     * Throws an error if the popover instance is not provided.
     * @param {?} popover
     * @return {?}
     */
    function (popover) {
        if (!popover || !(popover instanceof SatPopover)) {
            throw getInvalidPopoverError();
        }
    };
    SatPopoverAnchor.decorators = [
        { type: core.Directive, args: [{
                    selector: '[satPopoverAnchorFor]',
                    exportAs: 'satPopoverAnchor',
                    providers: [PopoverAnchoringService],
                },] },
    ];
    /** @nocollapse */
    SatPopoverAnchor.ctorParameters = function () { return [
        { type: core.ElementRef, },
        { type: core.ViewContainerRef, },
        { type: PopoverAnchoringService, },
    ]; };
    SatPopoverAnchor.propDecorators = {
        "attachedPopover": [{ type: core.Input, args: ['satPopoverAnchorFor',] },],
        "popoverOpened": [{ type: core.Output },],
        "popoverClosed": [{ type: core.Output },],
    };
    return SatPopoverAnchor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SatPopoverModule = (function () {
    function SatPopoverModule() {
    }
    SatPopoverModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        overlay.OverlayModule,
                        a11y.A11yModule,
                        BidiModule,
                    ],
                    declarations: [
                        SatPopover,
                        SatPopoverAnchor,
                    ],
                    exports: [
                        SatPopover,
                        SatPopoverAnchor,
                        BidiModule,
                    ]
                },] },
    ];
    /** @nocollapse */
    SatPopoverModule.ctorParameters = function () { return []; };
    return SatPopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

exports.SatPopoverModule = SatPopoverModule;
exports.SatPopoverAnchor = SatPopoverAnchor;
exports.SatPopover = SatPopover;
exports.b = PopoverAnchoringService;
exports.a = transformPopover;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=sat-popover.umd.js.map
