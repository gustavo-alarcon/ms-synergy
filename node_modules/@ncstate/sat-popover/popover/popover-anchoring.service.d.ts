import { ElementRef, NgZone, OnDestroy, ViewContainerRef } from '@angular/core';
import { Overlay, OverlayRef } from '@angular/cdk/overlay';
import { Directionality } from '@angular/cdk/bidi';
import { Subject } from 'rxjs';
import { SatPopover } from './popover.component';
export declare class PopoverAnchoringService implements OnDestroy {
    private _overlay;
    private _ngZone;
    private _dir;
    /** Emits when the popover is opened. */
    popoverOpened: Subject<void>;
    /** Emits when the popover is closed. */
    popoverClosed: Subject<void>;
    /** Reference to the overlay containing the popover component. */
    _overlayRef: OverlayRef;
    /** Reference to the target popover. */
    private _popover;
    /** Reference to the view container for the popover template. */
    private _viewContainerRef;
    /** Reference to the anchor element. */
    private _anchor;
    /** Reference to a template portal where the overlay will be attached. */
    private _portal;
    /** Communications channel with the popover. */
    private _notifications;
    /** Single subscription to notifications service events. */
    private _notificationsSubscription;
    /** Single subscription to position changes. */
    private _positionChangeSubscription;
    /** Whether the popover is presently open. */
    private _popoverOpen;
    /** Emits when the directive is destroyed. */
    private _onDestroy;
    constructor(_overlay: Overlay, _ngZone: NgZone, _dir: Directionality);
    ngOnDestroy(): void;
    /** Anchor a popover instance to a view and connection element. */
    anchor(popover: SatPopover, viewContainerRef: ViewContainerRef, anchor: ElementRef): void;
    /** Gets whether the popover is presently open. */
    isPopoverOpen(): boolean;
    /** Toggles the popover between the open and closed states. */
    togglePopover(): void;
    /** Opens the popover. */
    openPopover(): void;
    /** Closes the popover. */
    closePopover(value?: any): void;
    /** Create an overlay to be attached to the portal. */
    createOverlay(): OverlayRef;
    /** Removes the popover from the DOM. Does NOT update open state. */
    private _destroyPopover();
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     */
    private _destroyPopoverOnceClosed();
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     */
    private _subscribeToNotifications();
    /** Close popover when backdrop is clicked. */
    private _subscribeToBackdrop();
    /** Close popover when escape keydown event occurs. */
    private _subscribeToEscape();
    /** Set state back to closed when detached. */
    private _subscribeToDetachments();
    /** Save the opened state of the popover and emit. */
    private _saveOpenedState();
    /** Save the closed state of the popover and emit. */
    private _saveClosedState(value?);
    /** Gets the text direction of the containing app. */
    private _getDirection();
    /** Create and return a config for creating the overlay. */
    private _getOverlayConfig(config, anchor);
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     */
    private _subscribeToPositionChanges(position);
    /** Map a scroll strategy string type to an instance of a scroll strategy. */
    private _getScrollStrategyInstance(strategy);
    /** Create and return a position strategy based on config provided to the component instance. */
    private _getPositionStrategy(horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor);
    /** Add fallbacks to a given strategy based around target alignments. */
    private _addFallbacks(strategy, hTarget, vTarget);
    /**
    * Convert a specific horizontal and vertical alignment into a fallback and apply it to
    * the strategy.
    */
    private _applyFallback(strategy, horizontalAlign, verticalAlign);
}
