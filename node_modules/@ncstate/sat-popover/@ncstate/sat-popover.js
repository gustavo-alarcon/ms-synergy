import { Component, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';
import { CommonModule, DOCUMENT } from '@angular/common';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { A11yModule, FocusTrapFactory } from '@angular/cdk/a11y';
import { DOCUMENT as DOCUMENT$1 } from '@angular/platform-browser';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { animate, style, transition, trigger } from '@angular/animations';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { merge as merge$1 } from 'rxjs/observable/merge';
import { tap as tap$1 } from 'rxjs/operators/tap';
import { takeUntil as takeUntil$1 } from 'rxjs/operators/takeUntil';
import { ESCAPE } from '@angular/cdk/keycodes';
import { TemplatePortal } from '@angular/cdk/portal';
import { take as take$1 } from 'rxjs/operators/take';
import { filter as filter$1 } from 'rxjs/operators/filter';

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Injection token used to inject the document into Directionality.
 * This is used so that the value can be faked in tests.
 *
 * We can't use the real document in tests because changing the real `dir` causes geometry-based
 * tests in Safari to fail.
 *
 * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests
 * themselves use things like `querySelector` in test code.
 */
var DIR_DOCUMENT = new InjectionToken('cdk-dir-doc');
/**
 * The directionality (LTR / RTL) context for the application (or a subtree of it).
 * Exposes the current direction and a stream of direction changes.
 */
var Directionality = /** @class */ (function () {
    function Directionality(_document) {
        /**
         * The current 'ltr' or 'rtl' value.
         */
        this.value = 'ltr';
        /**
         * Stream that emits whenever the 'ltr' / 'rtl' state changes.
         */
        this.change = new EventEmitter();
        if (_document) {
            // TODO: handle 'auto' value -
            // We still need to account for dir="auto".
            // It looks like HTMLElemenet.dir is also "auto" when that's set to the attribute,
            // but getComputedStyle return either "ltr" or "rtl". avoiding getComputedStyle for now
            var /** @type {?} */ bodyDir = _document.body ? _document.body.dir : null;
            var /** @type {?} */ htmlDir = _document.documentElement ? _document.documentElement.dir : null;
            this.value = /** @type {?} */ ((bodyDir || htmlDir || 'ltr'));
        }
    }
    Directionality.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    Directionality.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DIR_DOCUMENT,] },] },
    ]; };
    return Directionality;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * Directive to listen for changes of direction of part of the DOM.
 *
 * Provides itself as Directionality such that descendant directives only need to ever inject
 * Directionality to get the closest direction.
 */
var Dir = /** @class */ (function () {
    function Dir() {
        this._dir = 'ltr';
        /**
         * Whether the `value` has been set to its initial value.
         */
        this._isInitialized = false;
        /**
         * Event emitted when the direction changes.
         */
        this.change = new EventEmitter();
    }
    Object.defineProperty(Dir.prototype, "dir", {
        get: /**
         * \@docs-private
         * @return {?}
         */
        function () { return this._dir; },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            var /** @type {?} */ old = this._dir;
            this._dir = v;
            if (old !== this._dir && this._isInitialized) {
                this.change.emit(this._dir);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dir.prototype, "value", {
        /** Current layout direction of the element. */
        get: /**
         * Current layout direction of the element.
         * @return {?}
         */
        function () { return this.dir; },
        enumerable: true,
        configurable: true
    });
    /** Initialize once default value has been set. */
    /**
     * Initialize once default value has been set.
     * @return {?}
     */
    Dir.prototype.ngAfterContentInit = /**
     * Initialize once default value has been set.
     * @return {?}
     */
    function () {
        this._isInitialized = true;
    };
    Dir.decorators = [
        { type: Directive, args: [{
                    selector: '[dir]',
                    providers: [{ provide: Directionality, useExisting: Dir }],
                    host: { '[dir]': 'dir' },
                    exportAs: 'dir',
                },] },
    ];
    /** @nocollapse */
    Dir.ctorParameters = function () { return []; };
    Dir.propDecorators = {
        "change": [{ type: Output, args: ['dirChange',] },],
        "dir": [{ type: Input, args: ['dir',] },],
    };
    return Dir;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var BidiModule = /** @class */ (function () {
    function BidiModule() {
    }
    BidiModule.decorators = [
        { type: NgModule, args: [{
                    exports: [Dir],
                    declarations: [Dir],
                    providers: [
                        { provide: DIR_DOCUMENT, useExisting: DOCUMENT },
                        Directionality,
                    ]
                },] },
    ];
    /** @nocollapse */
    BidiModule.ctorParameters = function () { return []; };
    return BidiModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const transformPopover = trigger('transformPopover', [
    transition(':enter', [
        style({ opacity: 0, transform: 'scale(0.3)' }),
        animate('{{openTransition}}', style({ opacity: 1, transform: 'scale(1)' }))
    ]),
    transition(':leave', [
        animate('{{closeTransition}}', style({ opacity: 0, transform: 'scale(0.5)' }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const NotificationAction = {
    /** Popover should open. */
    OPEN: 0,
    /** Popover should close. */
    CLOSE: 1,
    /** Popover should toggle open or closed. */
    TOGGLE: 2,
    /** Popover has new target positions. */
    REPOSITION: 3,
    /** Popover needs new configuration. */
    UPDATE_CONFIG: 4,
};
NotificationAction[NotificationAction.OPEN] = "OPEN";
NotificationAction[NotificationAction.CLOSE] = "CLOSE";
NotificationAction[NotificationAction.TOGGLE] = "TOGGLE";
NotificationAction[NotificationAction.REPOSITION] = "REPOSITION";
NotificationAction[NotificationAction.UPDATE_CONFIG] = "UPDATE_CONFIG";
/**
 * Event object for dispatching to anchor.
 */
class PopoverNotification {
    /**
     * @param {?} action
     * @param {?=} value
     */
    constructor(action, value) {
        this.action = action;
        this.value = value;
    }
}
class PopoverNotificationService {
    constructor() {
        this.store = new Subject$1();
    }
    /**
     * Dispatch a notification to all subscribers.
     * @param {?} notification
     * @return {?}
     */
    dispatch(notification) {
        this.store.next(notification);
    }
    /**
     * Stream of notification events.
     * @return {?}
     */
    events() {
        return this.store.asObservable();
    }
    /**
     * Complete event stream.
     * @return {?}
     */
    dispose() {
        this.store.complete();
    }
}
PopoverNotificationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PopoverNotificationService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @return {?}
 */
function getInvalidPopoverError() {
    return Error('SatPopoverAnchor must be provided an SatPopover component instance.');
}
/**
 * @return {?}
 */
function getUnanchoredPopoverError() {
    return Error('SatPopover is not anchored to any SatPopoverAnchor.');
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidHorizontalAlignError(alignment) {
    return Error(generateGenericError('horizontalAlign/xAlign', alignment, VALID_HORIZ_ALIGN));
}
/**
 * @param {?} alignment
 * @return {?}
 */
function getInvalidVerticalAlignError(alignment) {
    return Error(generateGenericError('verticalAlign/yAlign', alignment, VALID_VERT_ALIGN));
}
/**
 * @param {?} strategy
 * @return {?}
 */
function getInvalidScrollStrategyError(strategy) {
    return Error(generateGenericError('scrollStrategy', strategy, VALID_SCROLL));
}
/**
 * @param {?} apiName
 * @param {?} invalid
 * @param {?} valid
 * @return {?}
 */
function generateGenericError(apiName, invalid, valid) {
    return `Invalid ${apiName}: '${invalid}'. Valid options are ` +
        `${valid.map(v => `'${v}'`).join(', ')}.`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const VALID_SCROLL = ['noop', 'block', 'reposition', 'close'];
const VALID_HORIZ_ALIGN = ['before', 'start', 'center', 'end', 'after'];
const VALID_VERT_ALIGN = ['above', 'start', 'center', 'end', 'below'];
// See http://cubic-bezier.com/#.25,.8,.25,1 for reference.
const DEFAULT_TRANSITION = '200ms cubic-bezier(0.25, 0.8, 0.25, 1)';
class SatPopover {
    /**
     * @param {?} _focusTrapFactory
     * @param {?} _document
     */
    constructor(_focusTrapFactory, _document) {
        this._focusTrapFactory = _focusTrapFactory;
        this._document = _document;
        this._horizontalAlign = 'center';
        this._verticalAlign = 'center';
        this._forceAlignment = false;
        this._lockAlignment = false;
        this._autoFocus = true;
        this._scrollStrategy = 'reposition';
        this._hasBackdrop = false;
        this._interactiveClose = true;
        this._openTransition = DEFAULT_TRANSITION;
        this._closeTransition = DEFAULT_TRANSITION;
        /**
         * Optional backdrop class.
         */
        this.backdropClass = '';
        /**
         * Emits when the popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.closed = new EventEmitter();
        /**
         * Emits when the popover has finished opening.
         */
        this.afterOpen = new EventEmitter();
        /**
         * Emits when the popover has finished closing.
         */
        this.afterClose = new EventEmitter();
        /**
         * Emits when the backdrop is clicked.
         */
        this.backdropClicked = new EventEmitter();
        /**
         * Emits when a keydown event is targeted to this popover's overlay.
         */
        this.overlayKeydown = new EventEmitter();
        /**
         * Classes to be added to the popover for setting the correct transform origin.
         */
        this._classList = {};
        /**
         * Whether the popover is presently open.
         */
        this._open = false;
    }
    /**
     * Alignment of the popover on the horizontal axis.
     * @return {?}
     */
    get horizontalAlign() { return this._horizontalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set horizontalAlign(val) {
        this._validateHorizontalAlign(val);
        if (this._horizontalAlign !== val) {
            this._horizontalAlign = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Alignment of the popover on the x axis. Alias for `horizontalAlign`.
     * @return {?}
     */
    get xAlign() { return this.horizontalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set xAlign(val) { this.horizontalAlign = val; }
    /**
     * Alignment of the popover on the vertical axis.
     * @return {?}
     */
    get verticalAlign() { return this._verticalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set verticalAlign(val) {
        this._validateVerticalAlign(val);
        if (this._verticalAlign !== val) {
            this._verticalAlign = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Alignment of the popover on the y axis. Alias for `verticalAlign`.
     * @return {?}
     */
    get yAlign() { return this.verticalAlign; }
    /**
     * @param {?} val
     * @return {?}
     */
    set yAlign(val) { this.verticalAlign = val; }
    /**
     * Whether the popover always opens with the specified alignment.
     * @return {?}
     */
    get forceAlignment() { return this._forceAlignment; }
    /**
     * @param {?} val
     * @return {?}
     */
    set forceAlignment(val) {
        const /** @type {?} */ coercedVal = coerceBooleanProperty(val);
        if (this._forceAlignment !== coercedVal) {
            this._forceAlignment = coercedVal;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Whether the popover's alignment is locked after opening. This prevents the popover
     * from changing its alignement when scrolling or changing the size of the viewport.
     * @return {?}
     */
    get lockAlignment() { return this._lockAlignment; }
    /**
     * @param {?} val
     * @return {?}
     */
    set lockAlignment(val) {
        const /** @type {?} */ coercedVal = coerceBooleanProperty(val);
        if (this._lockAlignment !== coercedVal) {
            this._lockAlignment = coerceBooleanProperty(val);
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.REPOSITION));
        }
    }
    /**
     * Whether the first focusable element should be focused on open.
     * @return {?}
     */
    get autoFocus() { return this._autoFocus; }
    /**
     * @param {?} val
     * @return {?}
     */
    set autoFocus(val) {
        this._autoFocus = coerceBooleanProperty(val);
    }
    /**
     * How the popover should handle scrolling.
     * @return {?}
     */
    get scrollStrategy() { return this._scrollStrategy; }
    /**
     * @param {?} val
     * @return {?}
     */
    set scrollStrategy(val) {
        this._validateScrollStrategy(val);
        if (this._scrollStrategy !== val) {
            this._scrollStrategy = val;
            this._dispatchConfigNotification(new PopoverNotification(NotificationAction.UPDATE_CONFIG));
        }
    }
    /**
     * Whether the popover should have a backdrop (includes closing on click).
     * @return {?}
     */
    get hasBackdrop() { return this._hasBackdrop; }
    /**
     * @param {?} val
     * @return {?}
     */
    set hasBackdrop(val) {
        this._hasBackdrop = coerceBooleanProperty(val);
    }
    /**
     * Whether the popover should close when the user clicks the backdrop or presses ESC.
     * @return {?}
     */
    get interactiveClose() { return this._interactiveClose; }
    /**
     * @param {?} val
     * @return {?}
     */
    set interactiveClose(val) {
        this._interactiveClose = coerceBooleanProperty(val);
    }
    /**
     * Custom transition to use while opening.
     * @return {?}
     */
    get openTransition() { return this._openTransition; }
    /**
     * @param {?} val
     * @return {?}
     */
    set openTransition(val) {
        if (val) {
            this._openTransition = val;
        }
    }
    /**
     * Custom transition to use while closing.
     * @return {?}
     */
    get closeTransition() { return this._closeTransition; }
    /**
     * @param {?} val
     * @return {?}
     */
    set closeTransition(val) {
        if (val) {
            this._closeTransition = val;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._setAlignmentClasses();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._notifications) {
            this._notifications.dispose();
        }
    }
    /**
     * Open this popover.
     * @return {?}
     */
    open() {
        const /** @type {?} */ notification = new PopoverNotification(NotificationAction.OPEN);
        this._dispatchActionNotification(notification);
    }
    /**
     * Close this popover.
     * @param {?=} value
     * @return {?}
     */
    close(value) {
        const /** @type {?} */ notification = new PopoverNotification(NotificationAction.CLOSE, value);
        this._dispatchActionNotification(notification);
    }
    /**
     * Toggle this popover open or closed.
     * @return {?}
     */
    toggle() {
        const /** @type {?} */ notification = new PopoverNotification(NotificationAction.TOGGLE);
        this._dispatchActionNotification(notification);
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isOpen() {
        return this._open;
    }
    /**
     * Gets an animation config with customized (or default) transition values.
     * @return {?}
     */
    _getAnimation() {
        return {
            value: 'visible',
            params: { openTransition: this.openTransition, closeTransition: this.closeTransition }
        };
    }
    /**
     * Callback for when the popover is finished animating in or out.
     * @param {?} event
     * @return {?}
     */
    _onAnimationDone(event) {
        if (event.toState === 'visible') {
            this._trapFocus();
            this.afterOpen.emit();
        }
        else if (event.toState === 'void') {
            this._restoreFocus();
            this.afterClose.emit();
        }
    }
    /**
     * Apply alignment classes based on alignment inputs.
     * @param {?=} horizAlign
     * @param {?=} vertAlign
     * @return {?}
     */
    _setAlignmentClasses(horizAlign = this.horizontalAlign, vertAlign = this.verticalAlign) {
        this._classList['sat-popover-before'] = horizAlign === 'before' || horizAlign === 'end';
        this._classList['sat-popover-after'] = horizAlign === 'after' || horizAlign === 'start';
        this._classList['sat-popover-above'] = vertAlign === 'above' || vertAlign === 'end';
        this._classList['sat-popover-below'] = vertAlign === 'below' || vertAlign === 'start';
        this._classList['sat-popover-center'] = horizAlign === 'center' || vertAlign === 'center';
    }
    /**
     * Move the focus inside the focus trap and remember where to return later.
     * @return {?}
     */
    _trapFocus() {
        this._savePreviouslyFocusedElement();
        // There won't be a focus trap element if the close animation starts before open finishes
        if (!this._focusTrapElement) {
            return;
        }
        if (!this._focusTrap && this._focusTrapElement) {
            this._focusTrap = this._focusTrapFactory.create(this._focusTrapElement.nativeElement);
        }
        if (this.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
    }
    /**
     * Restore focus to the element focused before the popover opened. Also destroy trap.
     * @return {?}
     */
    _restoreFocus() {
        const /** @type {?} */ toFocus = this._previouslyFocusedElement;
        // Must check active element is focusable for IE sake
        if (toFocus && 'focus' in toFocus) {
            this._previouslyFocusedElement.focus();
        }
        this._previouslyFocusedElement = null;
        if (this._focusTrap) {
            this._focusTrap.destroy();
            this._focusTrap = undefined;
        }
    }
    /**
     * Save a reference to the element focused before the popover was opened.
     * @return {?}
     */
    _savePreviouslyFocusedElement() {
        if (this._document) {
            this._previouslyFocusedElement = /** @type {?} */ (this._document.activeElement);
        }
    }
    /**
     * Dispatch a notification to the notification service, if possible.
     * @param {?} notification
     * @return {?}
     */
    _dispatchConfigNotification(notification) {
        if (this._notifications) {
            this._notifications.dispatch(notification);
        }
    }
    /**
     * Dispatch a notification to the notification service and throw if unable to.
     * @param {?} notification
     * @return {?}
     */
    _dispatchActionNotification(notification) {
        if (!this._notifications) {
            throw getUnanchoredPopoverError();
        }
        this._notifications.dispatch(notification);
    }
    /**
     * Throws an error if the alignment is not a valid horizontalAlign.
     * @param {?} pos
     * @return {?}
     */
    _validateHorizontalAlign(pos) {
        if (VALID_HORIZ_ALIGN.indexOf(pos) === -1) {
            throw getInvalidHorizontalAlignError(pos);
        }
    }
    /**
     * Throws an error if the alignment is not a valid verticalAlign.
     * @param {?} pos
     * @return {?}
     */
    _validateVerticalAlign(pos) {
        if (VALID_VERT_ALIGN.indexOf(pos) === -1) {
            throw getInvalidVerticalAlignError(pos);
        }
    }
    /**
     * Throws an error if the scroll strategy is not a valid strategy.
     * @param {?} strategy
     * @return {?}
     */
    _validateScrollStrategy(strategy) {
        if (VALID_SCROLL.indexOf(strategy) === -1) {
            throw getInvalidScrollStrategyError(strategy);
        }
    }
}
SatPopover.decorators = [
    { type: Component, args: [{
                selector: 'sat-popover',
                encapsulation: ViewEncapsulation.None,
                animations: [transformPopover],
                styles: ["/** * Applies styles for users in high contrast mode. Note that this only applies * to Microsoft browsers. Chrome can be included by checking for the `html[hc]` * attribute, however Chrome handles high contrast differently. */ /* Theme for the ripple elements.*/ /** The mixins below are shared between mat-menu and mat-select */ /** * This mixin adds the correct panel transform styles based * on the direction that the menu panel opens. */ /* stylelint-disable material/no-prefixes */ /* stylelint-enable */ /** * This mixin contains shared option styles between the select and * autocomplete components. */ .cdk-overlay-container, .cdk-global-overlay-wrapper { pointer-events: none; top: 0; left: 0; height: 100%; width: 100%; } .cdk-overlay-container { position: fixed; z-index: 1000; } .cdk-global-overlay-wrapper { display: flex; position: absolute; z-index: 1000; } .cdk-overlay-pane { position: absolute; pointer-events: auto; box-sizing: border-box; z-index: 1000; } .cdk-overlay-backdrop { position: absolute; top: 0; bottom: 0; left: 0; right: 0; z-index: 1000; pointer-events: auto; -webkit-tap-highlight-color: transparent; transition: opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1); opacity: 0; } .cdk-overlay-backdrop.cdk-overlay-backdrop-showing { opacity: 0.48; } .cdk-overlay-dark-backdrop { background: rgba(0, 0, 0, 0.6); } .cdk-overlay-transparent-backdrop { background: none; } .cdk-global-scrollblock { position: fixed; width: 100%; overflow-y: scroll; } .sat-popover-container.sat-popover-before.sat-popover-above { transform-origin: right bottom; } [dir='rtl'] .sat-popover-container.sat-popover-before.sat-popover-above { transform-origin: left bottom; } .sat-popover-container.sat-popover-before.sat-popover-center { transform-origin: right center; } [dir='rtl'] .sat-popover-container.sat-popover-before.sat-popover-center { transform-origin: left center; } .sat-popover-container.sat-popover-before.sat-popover-below { transform-origin: right top; } [dir='rtl'] .sat-popover-container.sat-popover-before.sat-popover-below { transform-origin: left top; } .sat-popover-container.sat-popover-center.sat-popover-above { transform-origin: center bottom; } .sat-popover-container.sat-popover-center.sat-popover-below { transform-origin: center top; } .sat-popover-container.sat-popover-after.sat-popover-above { transform-origin: left bottom; } [dir='rtl'] .sat-popover-container.sat-popover-after.sat-popover-above { transform-origin: right bottom; } .sat-popover-container.sat-popover-after.sat-popover-center { transform-origin: left center; } [dir='rtl'] .sat-popover-container.sat-popover-after.sat-popover-center { transform-origin: right center; } .sat-popover-container.sat-popover-after.sat-popover-below { transform-origin: left top; } [dir='rtl'] .sat-popover-container.sat-popover-after.sat-popover-below { transform-origin: right top; } "],
                template: "<ng-template> <div class=\"sat-popover-container\" #focusTrapElement [ngClass]=\"_classList\" [@transformPopover]=\"_getAnimation()\" (@transformPopover.done)=\"_onAnimationDone($event)\"> <ng-content></ng-content> </div> </ng-template> ",
            },] },
];
/** @nocollapse */
SatPopover.ctorParameters = () => [
    { type: FocusTrapFactory, },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT$1,] },] },
];
SatPopover.propDecorators = {
    "horizontalAlign": [{ type: Input },],
    "xAlign": [{ type: Input },],
    "verticalAlign": [{ type: Input },],
    "yAlign": [{ type: Input },],
    "forceAlignment": [{ type: Input },],
    "lockAlignment": [{ type: Input },],
    "autoFocus": [{ type: Input },],
    "scrollStrategy": [{ type: Input },],
    "hasBackdrop": [{ type: Input },],
    "interactiveClose": [{ type: Input },],
    "openTransition": [{ type: Input },],
    "closeTransition": [{ type: Input },],
    "backdropClass": [{ type: Input },],
    "opened": [{ type: Output },],
    "closed": [{ type: Output },],
    "afterOpen": [{ type: Output },],
    "afterClose": [{ type: Output },],
    "backdropClicked": [{ type: Output },],
    "overlayKeydown": [{ type: Output },],
    "_templateRef": [{ type: ViewChild, args: [TemplateRef,] },],
    "_focusTrapElement": [{ type: ViewChild, args: ['focusTrapElement',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class PopoverAnchoringService {
    /**
     * @param {?} _overlay
     * @param {?} _ngZone
     * @param {?} _dir
     */
    constructor(_overlay, _ngZone, _dir) {
        this._overlay = _overlay;
        this._ngZone = _ngZone;
        this._dir = _dir;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new Subject$1();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new Subject$1();
        /**
         * Whether the popover is presently open.
         */
        this._popoverOpen = false;
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject$1();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // Destroy popover before terminating subscriptions so that any resulting
        // detachments update 'closed state'
        this._destroyPopover();
        // Terminate subscriptions
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._onDestroy.next();
        this._onDestroy.complete();
        this.popoverOpened.complete();
        this.popoverClosed.complete();
    }
    /**
     * Anchor a popover instance to a view and connection element.
     * @param {?} popover
     * @param {?} viewContainerRef
     * @param {?} anchor
     * @return {?}
     */
    anchor(popover, viewContainerRef, anchor) {
        // Destroy any previous popovers
        this._destroyPopover();
        // Assign local refs
        this._popover = popover;
        this._viewContainerRef = viewContainerRef;
        this._anchor = anchor;
        // Provide notification service as a communication channel between popover and anchor.
        // Then subscribe to notifications to take appropriate actions.
        this._popover._notifications = this._notifications = new PopoverNotificationService();
        this._subscribeToNotifications();
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._popoverOpen;
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    }
    /**
     * Opens the popover.
     * @return {?}
     */
    openPopover() {
        if (!this._popoverOpen) {
            this.createOverlay();
            this._subscribeToBackdrop();
            this._subscribeToEscape();
            this._subscribeToDetachments();
            this._saveOpenedState();
        }
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    closePopover(value) {
        if (this._overlayRef) {
            this._saveClosedState(value);
            this._overlayRef.detach();
        }
    }
    /**
     * Create an overlay to be attached to the portal.
     * @return {?}
     */
    createOverlay() {
        // Create overlay if it doesn't yet exist
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this._popover._templateRef, this._viewContainerRef);
            const /** @type {?} */ popoverConfig = {
                horizontalAlign: this._popover.horizontalAlign,
                verticalAlign: this._popover.verticalAlign,
                hasBackdrop: this._popover.hasBackdrop,
                backdropClass: this._popover.backdropClass,
                scrollStrategy: this._popover.scrollStrategy,
                forceAlignment: this._popover.forceAlignment,
                lockAlignment: this._popover.lockAlignment,
            };
            const /** @type {?} */ overlayConfig = this._getOverlayConfig(popoverConfig, this._anchor);
            this._subscribeToPositionChanges(/** @type {?} */ (overlayConfig.positionStrategy));
            this._overlayRef = this._overlay.create(overlayConfig);
        }
        // Actually open the popover
        this._overlayRef.attach(this._portal);
        return this._overlayRef;
    }
    /**
     * Removes the popover from the DOM. Does NOT update open state.
     * @return {?}
     */
    _destroyPopover() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
    }
    /**
     * Destroys the popover immediately if it is closed, or waits until it
     * has been closed to destroy it.
     * @return {?}
     */
    _destroyPopoverOnceClosed() {
        if (this.isPopoverOpen() && this._overlayRef) {
            this._overlayRef.detachments().pipe(take$1(1), takeUntil$1(this._onDestroy)).subscribe(() => this._destroyPopover());
        }
        else {
            this._destroyPopover();
        }
    }
    /**
     * Call appropriate anchor method when an event is dispatched through
     * the notification service.
     * @return {?}
     */
    _subscribeToNotifications() {
        if (this._notificationsSubscription) {
            this._notificationsSubscription.unsubscribe();
        }
        this._notificationsSubscription = this._notifications.events()
            .subscribe(event => {
            switch (event.action) {
                case NotificationAction.OPEN:
                    this.openPopover();
                    break;
                case NotificationAction.CLOSE:
                    this.closePopover(event.value);
                    break;
                case NotificationAction.TOGGLE:
                    this.togglePopover();
                    break;
                case NotificationAction.REPOSITION:
                // TODO: When the overlay's position can be dynamically changed, do not destroy
                case NotificationAction.UPDATE_CONFIG:
                    this._destroyPopoverOnceClosed();
                    break;
            }
        });
    }
    /**
     * Close popover when backdrop is clicked.
     * @return {?}
     */
    _subscribeToBackdrop() {
        this._overlayRef
            .backdropClick()
            .pipe(tap$1(() => this._popover.backdropClicked.emit()), filter$1(() => this._popover.interactiveClose), takeUntil$1(this.popoverClosed), takeUntil$1(this._onDestroy))
            .subscribe(() => this.closePopover());
    }
    /**
     * Close popover when escape keydown event occurs.
     * @return {?}
     */
    _subscribeToEscape() {
        this._overlayRef
            .keydownEvents()
            .pipe(tap$1(event => this._popover.overlayKeydown.emit(event)), filter$1(event => event.keyCode === ESCAPE), filter$1(() => this._popover.interactiveClose), takeUntil$1(this.popoverClosed), takeUntil$1(this._onDestroy))
            .subscribe(() => this.closePopover());
    }
    /**
     * Set state back to closed when detached.
     * @return {?}
     */
    _subscribeToDetachments() {
        this._overlayRef
            .detachments()
            .pipe(takeUntil$1(this._onDestroy))
            .subscribe(() => this._saveClosedState());
    }
    /**
     * Save the opened state of the popover and emit.
     * @return {?}
     */
    _saveOpenedState() {
        if (!this._popoverOpen) {
            this._popover._open = this._popoverOpen = true;
            this.popoverOpened.next();
            this._popover.opened.emit();
        }
    }
    /**
     * Save the closed state of the popover and emit.
     * @param {?=} value
     * @return {?}
     */
    _saveClosedState(value) {
        if (this._popoverOpen) {
            this._popover._open = this._popoverOpen = false;
            this.popoverClosed.next(value);
            this._popover.closed.emit(value);
        }
    }
    /**
     * Gets the text direction of the containing app.
     * @return {?}
     */
    _getDirection() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * Create and return a config for creating the overlay.
     * @param {?} config
     * @param {?} anchor
     * @return {?}
     */
    _getOverlayConfig(config, anchor) {
        return new OverlayConfig({
            positionStrategy: this._getPositionStrategy(config.horizontalAlign, config.verticalAlign, config.forceAlignment, config.lockAlignment, anchor),
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass || 'cdk-overlay-transparent-backdrop',
            scrollStrategy: this._getScrollStrategyInstance(config.scrollStrategy),
            direction: this._getDirection(),
        });
    }
    /**
     * Listen to changes in the position of the overlay and set the correct alignment classes,
     * ensuring that the animation origin is correct, even with a fallback position.
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositionChanges(position) {
        if (this._positionChangeSubscription) {
            this._positionChangeSubscription.unsubscribe();
        }
        this._positionChangeSubscription = position.onPositionChange
            .pipe(takeUntil$1(this._onDestroy))
            .subscribe(change => {
            // Position changes may occur outside the Angular zone
            this._ngZone.run(() => {
                this._popover._setAlignmentClasses(getHorizontalPopoverAlignment(change.connectionPair.overlayX), getVerticalPopoverAlignment(change.connectionPair.overlayY));
            });
        });
    }
    /**
     * Map a scroll strategy string type to an instance of a scroll strategy.
     * @param {?} strategy
     * @return {?}
     */
    _getScrollStrategyInstance(strategy) {
        switch (strategy) {
            case 'block':
                return this._overlay.scrollStrategies.block();
            case 'reposition':
                return this._overlay.scrollStrategies.reposition();
            case 'close':
                return this._overlay.scrollStrategies.close();
            case 'noop':
            default:
                return this._overlay.scrollStrategies.noop();
        }
    }
    /**
     * Create and return a position strategy based on config provided to the component instance.
     * @param {?} horizontalTarget
     * @param {?} verticalTarget
     * @param {?} forceAlignment
     * @param {?} lockAlignment
     * @param {?} anchor
     * @return {?}
     */
    _getPositionStrategy(horizontalTarget, verticalTarget, forceAlignment, lockAlignment, anchor) {
        // Attach the overlay at the preferred position
        const { originX, overlayX } = getHorizontalConnectionPosPair(horizontalTarget);
        const { originY, overlayY } = getVerticalConnectionPosPair(verticalTarget);
        const /** @type {?} */ strategy = this._overlay.position()
            .connectedTo(anchor, { originX, originY }, { overlayX, overlayY })
            .withDirection(this._getDirection())
            .withLockedPosition(lockAlignment);
        // Unless the alignment is forced, add fallbacks based on the preferred positions
        if (!forceAlignment) {
            this._addFallbacks(strategy, horizontalTarget, verticalTarget);
        }
        return strategy;
    }
    /**
     * Add fallbacks to a given strategy based around target alignments.
     * @param {?} strategy
     * @param {?} hTarget
     * @param {?} vTarget
     * @return {?}
     */
    _addFallbacks(strategy, hTarget, vTarget) {
        // Determine if the target alignments overlap the anchor
        const /** @type {?} */ horizontalOverlapAllowed = hTarget !== 'before' && hTarget !== 'after';
        const /** @type {?} */ verticalOverlapAllowed = vTarget !== 'above' && vTarget !== 'below';
        // If a target alignment doesn't cover the anchor, don't let any of the fallback alignments
        // cover the anchor
        const /** @type {?} */ possibleHorizontalAlignments = horizontalOverlapAllowed ?
            ['before', 'start', 'center', 'end', 'after'] :
            ['before', 'after'];
        const /** @type {?} */ possibleVerticalAlignments = verticalOverlapAllowed ?
            ['above', 'start', 'center', 'end', 'below'] :
            ['above', 'below'];
        // Create fallbacks for each allowed prioritized fallback alignment combo
        const /** @type {?} */ fallbacks = [];
        prioritizeAroundTarget(hTarget, possibleHorizontalAlignments).forEach(h => {
            prioritizeAroundTarget(vTarget, possibleVerticalAlignments).forEach(v => {
                fallbacks.push({ h, v });
            });
        });
        // Remove the first fallback since it will be the target alignment that is already applied
        fallbacks.slice(1, fallbacks.length)
            .forEach(({ h, v }) => this._applyFallback(strategy, h, v));
    }
    /**
     * Convert a specific horizontal and vertical alignment into a fallback and apply it to
     * the strategy.
     * @param {?} strategy
     * @param {?} horizontalAlign
     * @param {?} verticalAlign
     * @return {?}
     */
    _applyFallback(strategy, horizontalAlign, verticalAlign) {
        const { originX, overlayX } = getHorizontalConnectionPosPair(horizontalAlign);
        const { originY, overlayY } = getVerticalConnectionPosPair(verticalAlign);
        strategy.withFallbackPosition({ originX, originY }, { overlayX, overlayY });
    }
}
PopoverAnchoringService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PopoverAnchoringService.ctorParameters = () => [
    { type: Overlay, },
    { type: NgZone, },
    { type: Directionality, decorators: [{ type: Optional },] },
];
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} h
 * @return {?}
 */
function getHorizontalPopoverAlignment(h) {
    if (h === 'start') {
        return 'after';
    }
    if (h === 'end') {
        return 'before';
    }
    return 'center';
}
/**
 * Helper function to convert an overlay connection position to equivalent popover alignment.
 * @param {?} v
 * @return {?}
 */
function getVerticalPopoverAlignment(v) {
    if (v === 'top') {
        return 'below';
    }
    if (v === 'bottom') {
        return 'above';
    }
    return 'center';
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} h
 * @return {?}
 */
function getHorizontalConnectionPosPair(h) {
    switch (h) {
        case 'before':
            return { originX: 'start', overlayX: 'end' };
        case 'start':
            return { originX: 'start', overlayX: 'start' };
        case 'end':
            return { originX: 'end', overlayX: 'end' };
        case 'after':
            return { originX: 'end', overlayX: 'start' };
        default:
            return { originX: 'center', overlayX: 'center' };
    }
}
/**
 * Helper function to convert alignment to origin/overlay position pair.
 * @param {?} v
 * @return {?}
 */
function getVerticalConnectionPosPair(v) {
    switch (v) {
        case 'above':
            return { originY: 'top', overlayY: 'bottom' };
        case 'start':
            return { originY: 'top', overlayY: 'top' };
        case 'end':
            return { originY: 'bottom', overlayY: 'bottom' };
        case 'below':
            return { originY: 'bottom', overlayY: 'top' };
        default:
            return { originY: 'center', overlayY: 'center' };
    }
}
/**
 * Helper function that takes an ordered array options and returns a reorderded
 * array around the target item. e.g.:
 *
 * target: 3; options: [1, 2, 3, 4, 5, 6, 7];
 *
 * return: [3, 4, 2, 5, 1, 6, 7]
 * @template T
 * @param {?} target
 * @param {?} options
 * @return {?}
 */
function prioritizeAroundTarget(target, options) {
    const /** @type {?} */ targetIndex = options.indexOf(target);
    // Set the first item to be the target
    const /** @type {?} */ reordered = [target];
    // Make left and right stacks where the highest priority item is last
    const /** @type {?} */ left = options.slice(0, targetIndex);
    const /** @type {?} */ right = options.slice(targetIndex + 1, options.length).reverse();
    // Alternate between stacks until one is empty
    while (left.length && right.length) {
        reordered.push(right.pop());
        reordered.push(left.pop());
    }
    // Flush out right side
    while (right.length) {
        reordered.push(right.pop());
    }
    // Flush out left side
    while (left.length) {
        reordered.push(left.pop());
    }
    return reordered;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SatPopoverAnchor {
    /**
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _anchoring
     */
    constructor(_elementRef, _viewContainerRef, _anchoring) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._anchoring = _anchoring;
        /**
         * Emits when the popover is opened.
         */
        this.popoverOpened = new EventEmitter();
        /**
         * Emits when the popover is closed.
         */
        this.popoverClosed = new EventEmitter();
        /**
         * Emits when the directive is destroyed.
         */
        this._onDestroy = new Subject$1();
    }
    /**
     * Reference to the popover instance.
     * @return {?}
     */
    get attachedPopover() { return this._attachedPopover; }
    /**
     * @param {?} value
     * @return {?}
     */
    set attachedPopover(value) {
        this._validateAttachedPopover(value);
        this._attachedPopover = value;
        // Anchor the popover to the element ref
        this._anchoring.anchor(this.attachedPopover, this._viewContainerRef, this._elementRef);
    }
    /**
     * Gets whether the popover is presently open.
     * @return {?}
     */
    isPopoverOpen() {
        return this._anchoring.isPopoverOpen();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Re-emit open and close events
        const /** @type {?} */ opened$ = this._anchoring.popoverOpened
            .pipe(tap$1(() => this.popoverOpened.emit()));
        const /** @type {?} */ closed$ = this._anchoring.popoverClosed
            .pipe(tap$1(value => this.popoverClosed.emit(value)));
        merge$1(opened$, closed$).pipe(takeUntil$1(this._onDestroy)).subscribe();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._onDestroy.next();
        this._onDestroy.complete();
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        this._anchoring.togglePopover();
    }
    /**
     * Opens the popover.
     * @return {?}
     */
    openPopover() {
        this._anchoring.openPopover();
    }
    /**
     * Closes the popover.
     * @param {?=} value
     * @return {?}
     */
    closePopover(value) {
        this._anchoring.closePopover(value);
    }
    /**
     * Throws an error if the popover instance is not provided.
     * @param {?} popover
     * @return {?}
     */
    _validateAttachedPopover(popover) {
        if (!popover || !(popover instanceof SatPopover)) {
            throw getInvalidPopoverError();
        }
    }
}
SatPopoverAnchor.decorators = [
    { type: Directive, args: [{
                selector: '[satPopoverAnchorFor]',
                exportAs: 'satPopoverAnchor',
                providers: [PopoverAnchoringService],
            },] },
];
/** @nocollapse */
SatPopoverAnchor.ctorParameters = () => [
    { type: ElementRef, },
    { type: ViewContainerRef, },
    { type: PopoverAnchoringService, },
];
SatPopoverAnchor.propDecorators = {
    "attachedPopover": [{ type: Input, args: ['satPopoverAnchorFor',] },],
    "popoverOpened": [{ type: Output },],
    "popoverClosed": [{ type: Output },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class SatPopoverModule {
}
SatPopoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    OverlayModule,
                    A11yModule,
                    BidiModule,
                ],
                declarations: [
                    SatPopover,
                    SatPopoverAnchor,
                ],
                exports: [
                    SatPopover,
                    SatPopoverAnchor,
                    BidiModule,
                ]
            },] },
];
/** @nocollapse */
SatPopoverModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { SatPopoverModule, SatPopoverAnchor, SatPopover, PopoverAnchoringService as ɵb, transformPopover as ɵa };
//# sourceMappingURL=sat-popover.js.map
